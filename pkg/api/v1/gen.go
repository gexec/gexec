// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// contextKey provides a type for use with context.WithValue.
type contextKey string

const (
	BasicScopes  contextKey = "Basic.Scopes"
	BearerScopes contextKey = "Bearer.Scopes"
	HeaderScopes contextKey = "Header.Scopes"
)

// Defines values for CredentialKind.
const (
	Empty CredentialKind = "empty"
	Login CredentialKind = "login"
	Shell CredentialKind = "shell"
)

var (
	// ErrCredentialKind defines an error if an invalid value gets mapped.
	ErrCredentialKind = fmt.Errorf("invalid type for CredentialKind")

	stringToCredentialKind = map[string]CredentialKind{
		"empty": Empty,
		"login": Login,
		"shell": Shell,
	}
)

// ToCredentialKind acts as a helper to map a string to the defined enum.
func ToCredentialKind(val string) (CredentialKind, error) {
	if res, ok := stringToCredentialKind[val]; ok {
		return res, nil
	}

	return CredentialKind(""), ErrCredentialKind
}

// Defines values for EnvironmentSecretKind.
const (
	EnvironmentSecretKindEnv EnvironmentSecretKind = "env"
	EnvironmentSecretKindVar EnvironmentSecretKind = "var"
)

var (
	// ErrEnvironmentSecretKind defines an error if an invalid value gets mapped.
	ErrEnvironmentSecretKind = fmt.Errorf("invalid type for EnvironmentSecretKind")

	stringToEnvironmentSecretKind = map[string]EnvironmentSecretKind{
		"env": EnvironmentSecretKindEnv,
		"var": EnvironmentSecretKindVar,
	}
)

// ToEnvironmentSecretKind acts as a helper to map a string to the defined enum.
func ToEnvironmentSecretKind(val string) (EnvironmentSecretKind, error) {
	if res, ok := stringToEnvironmentSecretKind[val]; ok {
		return res, nil
	}

	return EnvironmentSecretKind(""), ErrEnvironmentSecretKind
}

// Defines values for EnvironmentValueKind.
const (
	EnvironmentValueKindEnv EnvironmentValueKind = "env"
	EnvironmentValueKindVar EnvironmentValueKind = "var"
)

var (
	// ErrEnvironmentValueKind defines an error if an invalid value gets mapped.
	ErrEnvironmentValueKind = fmt.Errorf("invalid type for EnvironmentValueKind")

	stringToEnvironmentValueKind = map[string]EnvironmentValueKind{
		"env": EnvironmentValueKindEnv,
		"var": EnvironmentValueKindVar,
	}
)

// ToEnvironmentValueKind acts as a helper to map a string to the defined enum.
func ToEnvironmentValueKind(val string) (EnvironmentValueKind, error) {
	if res, ok := stringToEnvironmentValueKind[val]; ok {
		return res, nil
	}

	return EnvironmentValueKind(""), ErrEnvironmentValueKind
}

// Defines values for EventAction.
const (
	Create EventAction = "create"
	Delete EventAction = "delete"
	Update EventAction = "update"
)

var (
	// ErrEventAction defines an error if an invalid value gets mapped.
	ErrEventAction = fmt.Errorf("invalid type for EventAction")

	stringToEventAction = map[string]EventAction{
		"create": Create,
		"delete": Delete,
		"update": Update,
	}
)

// ToEventAction acts as a helper to map a string to the defined enum.
func ToEventAction(val string) (EventAction, error) {
	if res, ok := stringToEventAction[val]; ok {
		return res, nil
	}

	return EventAction(""), ErrEventAction
}

// Defines values for EventObjectType.
const (
	EventObjectTypeCredential   EventObjectType = "credential"
	EventObjectTypeEnvironment  EventObjectType = "environment"
	EventObjectTypeExecution    EventObjectType = "execution"
	EventObjectTypeGroup        EventObjectType = "group"
	EventObjectTypeGroupProject EventObjectType = "group_project"
	EventObjectTypeGroupUser    EventObjectType = "group_user"
	EventObjectTypeInventory    EventObjectType = "inventory"
	EventObjectTypeProject      EventObjectType = "project"
	EventObjectTypeProjectGroup EventObjectType = "project_group"
	EventObjectTypeProjectUser  EventObjectType = "project_user"
	EventObjectTypeRepository   EventObjectType = "repository"
	EventObjectTypeRunner       EventObjectType = "runner"
	EventObjectTypeSchedule     EventObjectType = "schedule"
	EventObjectTypeTemplate     EventObjectType = "template"
	EventObjectTypeUser         EventObjectType = "user"
	EventObjectTypeUserGroup    EventObjectType = "user_group"
	EventObjectTypeUserProject  EventObjectType = "user_project"
)

var (
	// ErrEventObjectType defines an error if an invalid value gets mapped.
	ErrEventObjectType = fmt.Errorf("invalid type for EventObjectType")

	stringToEventObjectType = map[string]EventObjectType{
		"credential":    EventObjectTypeCredential,
		"environment":   EventObjectTypeEnvironment,
		"execution":     EventObjectTypeExecution,
		"group":         EventObjectTypeGroup,
		"group_project": EventObjectTypeGroupProject,
		"group_user":    EventObjectTypeGroupUser,
		"inventory":     EventObjectTypeInventory,
		"project":       EventObjectTypeProject,
		"project_group": EventObjectTypeProjectGroup,
		"project_user":  EventObjectTypeProjectUser,
		"repository":    EventObjectTypeRepository,
		"runner":        EventObjectTypeRunner,
		"schedule":      EventObjectTypeSchedule,
		"template":      EventObjectTypeTemplate,
		"user":          EventObjectTypeUser,
		"user_group":    EventObjectTypeUserGroup,
		"user_project":  EventObjectTypeUserProject,
	}
)

// ToEventObjectType acts as a helper to map a string to the defined enum.
func ToEventObjectType(val string) (EventObjectType, error) {
	if res, ok := stringToEventObjectType[val]; ok {
		return res, nil
	}

	return EventObjectType(""), ErrEventObjectType
}

// Defines values for GroupProjectPerm.
const (
	GroupProjectPermAdmin GroupProjectPerm = "admin"
	GroupProjectPermOwner GroupProjectPerm = "owner"
	GroupProjectPermUser  GroupProjectPerm = "user"
)

var (
	// ErrGroupProjectPerm defines an error if an invalid value gets mapped.
	ErrGroupProjectPerm = fmt.Errorf("invalid type for GroupProjectPerm")

	stringToGroupProjectPerm = map[string]GroupProjectPerm{
		"admin": GroupProjectPermAdmin,
		"owner": GroupProjectPermOwner,
		"user":  GroupProjectPermUser,
	}
)

// ToGroupProjectPerm acts as a helper to map a string to the defined enum.
func ToGroupProjectPerm(val string) (GroupProjectPerm, error) {
	if res, ok := stringToGroupProjectPerm[val]; ok {
		return res, nil
	}

	return GroupProjectPerm(""), ErrGroupProjectPerm
}

// Defines values for InventoryKind.
const (
	File   InventoryKind = "file"
	Static InventoryKind = "static"
)

var (
	// ErrInventoryKind defines an error if an invalid value gets mapped.
	ErrInventoryKind = fmt.Errorf("invalid type for InventoryKind")

	stringToInventoryKind = map[string]InventoryKind{
		"file":   File,
		"static": Static,
	}
)

// ToInventoryKind acts as a helper to map a string to the defined enum.
func ToInventoryKind(val string) (InventoryKind, error) {
	if res, ok := stringToInventoryKind[val]; ok {
		return res, nil
	}

	return InventoryKind(""), ErrInventoryKind
}

// Defines values for TemplateSurveyKind.
const (
	Enum   TemplateSurveyKind = "enum"
	Number TemplateSurveyKind = "number"
	Secret TemplateSurveyKind = "secret"
	String TemplateSurveyKind = "string"
)

var (
	// ErrTemplateSurveyKind defines an error if an invalid value gets mapped.
	ErrTemplateSurveyKind = fmt.Errorf("invalid type for TemplateSurveyKind")

	stringToTemplateSurveyKind = map[string]TemplateSurveyKind{
		"enum":   Enum,
		"number": Number,
		"secret": Secret,
		"string": String,
	}
)

// ToTemplateSurveyKind acts as a helper to map a string to the defined enum.
func ToTemplateSurveyKind(val string) (TemplateSurveyKind, error) {
	if res, ok := stringToTemplateSurveyKind[val]; ok {
		return res, nil
	}

	return TemplateSurveyKind(""), ErrTemplateSurveyKind
}

// Defines values for TemplateVaultKind.
const (
	Password TemplateVaultKind = "password"
	Script   TemplateVaultKind = "script"
)

var (
	// ErrTemplateVaultKind defines an error if an invalid value gets mapped.
	ErrTemplateVaultKind = fmt.Errorf("invalid type for TemplateVaultKind")

	stringToTemplateVaultKind = map[string]TemplateVaultKind{
		"password": Password,
		"script":   Script,
	}
)

// ToTemplateVaultKind acts as a helper to map a string to the defined enum.
func ToTemplateVaultKind(val string) (TemplateVaultKind, error) {
	if res, ok := stringToTemplateVaultKind[val]; ok {
		return res, nil
	}

	return TemplateVaultKind(""), ErrTemplateVaultKind
}

// Defines values for UserGroupPerm.
const (
	UserGroupPermAdmin UserGroupPerm = "admin"
	UserGroupPermOwner UserGroupPerm = "owner"
	UserGroupPermUser  UserGroupPerm = "user"
)

var (
	// ErrUserGroupPerm defines an error if an invalid value gets mapped.
	ErrUserGroupPerm = fmt.Errorf("invalid type for UserGroupPerm")

	stringToUserGroupPerm = map[string]UserGroupPerm{
		"admin": UserGroupPermAdmin,
		"owner": UserGroupPermOwner,
		"user":  UserGroupPermUser,
	}
)

// ToUserGroupPerm acts as a helper to map a string to the defined enum.
func ToUserGroupPerm(val string) (UserGroupPerm, error) {
	if res, ok := stringToUserGroupPerm[val]; ok {
		return res, nil
	}

	return UserGroupPerm(""), ErrUserGroupPerm
}

// Defines values for UserProjectPerm.
const (
	UserProjectPermAdmin UserProjectPerm = "admin"
	UserProjectPermOwner UserProjectPerm = "owner"
	UserProjectPermUser  UserProjectPerm = "user"
)

var (
	// ErrUserProjectPerm defines an error if an invalid value gets mapped.
	ErrUserProjectPerm = fmt.Errorf("invalid type for UserProjectPerm")

	stringToUserProjectPerm = map[string]UserProjectPerm{
		"admin": UserProjectPermAdmin,
		"owner": UserProjectPermOwner,
		"user":  UserProjectPermUser,
	}
)

// ToUserProjectPerm acts as a helper to map a string to the defined enum.
func ToUserProjectPerm(val string) (UserProjectPerm, error) {
	if res, ok := stringToUserProjectPerm[val]; ok {
		return res, nil
	}

	return UserProjectPerm(""), ErrUserProjectPerm
}

// Defines values for SortOrderParam.
const (
	SortOrderParamAsc  SortOrderParam = "asc"
	SortOrderParamDesc SortOrderParam = "desc"
)

var (
	// ErrSortOrderParam defines an error if an invalid value gets mapped.
	ErrSortOrderParam = fmt.Errorf("invalid type for SortOrderParam")

	stringToSortOrderParam = map[string]SortOrderParam{
		"asc":  SortOrderParamAsc,
		"desc": SortOrderParamDesc,
	}
)

// ToSortOrderParam acts as a helper to map a string to the defined enum.
func ToSortOrderParam(val string) (SortOrderParam, error) {
	if res, ok := stringToSortOrderParam[val]; ok {
		return res, nil
	}

	return SortOrderParam(""), ErrSortOrderParam
}

// Defines values for ListGroupsParamsOrder.
const (
	ListGroupsParamsOrderAsc  ListGroupsParamsOrder = "asc"
	ListGroupsParamsOrderDesc ListGroupsParamsOrder = "desc"
)

var (
	// ErrListGroupsParamsOrder defines an error if an invalid value gets mapped.
	ErrListGroupsParamsOrder = fmt.Errorf("invalid type for ListGroupsParamsOrder")

	stringToListGroupsParamsOrder = map[string]ListGroupsParamsOrder{
		"asc":  ListGroupsParamsOrderAsc,
		"desc": ListGroupsParamsOrderDesc,
	}
)

// ToListGroupsParamsOrder acts as a helper to map a string to the defined enum.
func ToListGroupsParamsOrder(val string) (ListGroupsParamsOrder, error) {
	if res, ok := stringToListGroupsParamsOrder[val]; ok {
		return res, nil
	}

	return ListGroupsParamsOrder(""), ErrListGroupsParamsOrder
}

// Defines values for ListGroupProjectsParamsOrder.
const (
	ListGroupProjectsParamsOrderAsc  ListGroupProjectsParamsOrder = "asc"
	ListGroupProjectsParamsOrderDesc ListGroupProjectsParamsOrder = "desc"
)

var (
	// ErrListGroupProjectsParamsOrder defines an error if an invalid value gets mapped.
	ErrListGroupProjectsParamsOrder = fmt.Errorf("invalid type for ListGroupProjectsParamsOrder")

	stringToListGroupProjectsParamsOrder = map[string]ListGroupProjectsParamsOrder{
		"asc":  ListGroupProjectsParamsOrderAsc,
		"desc": ListGroupProjectsParamsOrderDesc,
	}
)

// ToListGroupProjectsParamsOrder acts as a helper to map a string to the defined enum.
func ToListGroupProjectsParamsOrder(val string) (ListGroupProjectsParamsOrder, error) {
	if res, ok := stringToListGroupProjectsParamsOrder[val]; ok {
		return res, nil
	}

	return ListGroupProjectsParamsOrder(""), ErrListGroupProjectsParamsOrder
}

// Defines values for ListGroupUsersParamsOrder.
const (
	ListGroupUsersParamsOrderAsc  ListGroupUsersParamsOrder = "asc"
	ListGroupUsersParamsOrderDesc ListGroupUsersParamsOrder = "desc"
)

var (
	// ErrListGroupUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListGroupUsersParamsOrder = fmt.Errorf("invalid type for ListGroupUsersParamsOrder")

	stringToListGroupUsersParamsOrder = map[string]ListGroupUsersParamsOrder{
		"asc":  ListGroupUsersParamsOrderAsc,
		"desc": ListGroupUsersParamsOrderDesc,
	}
)

// ToListGroupUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListGroupUsersParamsOrder(val string) (ListGroupUsersParamsOrder, error) {
	if res, ok := stringToListGroupUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListGroupUsersParamsOrder(""), ErrListGroupUsersParamsOrder
}

// Defines values for ListProjectsParamsOrder.
const (
	ListProjectsParamsOrderAsc  ListProjectsParamsOrder = "asc"
	ListProjectsParamsOrderDesc ListProjectsParamsOrder = "desc"
)

var (
	// ErrListProjectsParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectsParamsOrder = fmt.Errorf("invalid type for ListProjectsParamsOrder")

	stringToListProjectsParamsOrder = map[string]ListProjectsParamsOrder{
		"asc":  ListProjectsParamsOrderAsc,
		"desc": ListProjectsParamsOrderDesc,
	}
)

// ToListProjectsParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectsParamsOrder(val string) (ListProjectsParamsOrder, error) {
	if res, ok := stringToListProjectsParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectsParamsOrder(""), ErrListProjectsParamsOrder
}

// Defines values for ListProjectCredentialsParamsOrder.
const (
	ListProjectCredentialsParamsOrderAsc  ListProjectCredentialsParamsOrder = "asc"
	ListProjectCredentialsParamsOrderDesc ListProjectCredentialsParamsOrder = "desc"
)

var (
	// ErrListProjectCredentialsParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectCredentialsParamsOrder = fmt.Errorf("invalid type for ListProjectCredentialsParamsOrder")

	stringToListProjectCredentialsParamsOrder = map[string]ListProjectCredentialsParamsOrder{
		"asc":  ListProjectCredentialsParamsOrderAsc,
		"desc": ListProjectCredentialsParamsOrderDesc,
	}
)

// ToListProjectCredentialsParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectCredentialsParamsOrder(val string) (ListProjectCredentialsParamsOrder, error) {
	if res, ok := stringToListProjectCredentialsParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectCredentialsParamsOrder(""), ErrListProjectCredentialsParamsOrder
}

// Defines values for ListProjectEnvironmentsParamsOrder.
const (
	ListProjectEnvironmentsParamsOrderAsc  ListProjectEnvironmentsParamsOrder = "asc"
	ListProjectEnvironmentsParamsOrderDesc ListProjectEnvironmentsParamsOrder = "desc"
)

var (
	// ErrListProjectEnvironmentsParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectEnvironmentsParamsOrder = fmt.Errorf("invalid type for ListProjectEnvironmentsParamsOrder")

	stringToListProjectEnvironmentsParamsOrder = map[string]ListProjectEnvironmentsParamsOrder{
		"asc":  ListProjectEnvironmentsParamsOrderAsc,
		"desc": ListProjectEnvironmentsParamsOrderDesc,
	}
)

// ToListProjectEnvironmentsParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectEnvironmentsParamsOrder(val string) (ListProjectEnvironmentsParamsOrder, error) {
	if res, ok := stringToListProjectEnvironmentsParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectEnvironmentsParamsOrder(""), ErrListProjectEnvironmentsParamsOrder
}

// Defines values for ListProjectExecutionsParamsOrder.
const (
	ListProjectExecutionsParamsOrderAsc  ListProjectExecutionsParamsOrder = "asc"
	ListProjectExecutionsParamsOrderDesc ListProjectExecutionsParamsOrder = "desc"
)

var (
	// ErrListProjectExecutionsParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectExecutionsParamsOrder = fmt.Errorf("invalid type for ListProjectExecutionsParamsOrder")

	stringToListProjectExecutionsParamsOrder = map[string]ListProjectExecutionsParamsOrder{
		"asc":  ListProjectExecutionsParamsOrderAsc,
		"desc": ListProjectExecutionsParamsOrderDesc,
	}
)

// ToListProjectExecutionsParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectExecutionsParamsOrder(val string) (ListProjectExecutionsParamsOrder, error) {
	if res, ok := stringToListProjectExecutionsParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectExecutionsParamsOrder(""), ErrListProjectExecutionsParamsOrder
}

// Defines values for ListProjectGroupsParamsOrder.
const (
	ListProjectGroupsParamsOrderAsc  ListProjectGroupsParamsOrder = "asc"
	ListProjectGroupsParamsOrderDesc ListProjectGroupsParamsOrder = "desc"
)

var (
	// ErrListProjectGroupsParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectGroupsParamsOrder = fmt.Errorf("invalid type for ListProjectGroupsParamsOrder")

	stringToListProjectGroupsParamsOrder = map[string]ListProjectGroupsParamsOrder{
		"asc":  ListProjectGroupsParamsOrderAsc,
		"desc": ListProjectGroupsParamsOrderDesc,
	}
)

// ToListProjectGroupsParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectGroupsParamsOrder(val string) (ListProjectGroupsParamsOrder, error) {
	if res, ok := stringToListProjectGroupsParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectGroupsParamsOrder(""), ErrListProjectGroupsParamsOrder
}

// Defines values for ListProjectInventoriesParamsOrder.
const (
	ListProjectInventoriesParamsOrderAsc  ListProjectInventoriesParamsOrder = "asc"
	ListProjectInventoriesParamsOrderDesc ListProjectInventoriesParamsOrder = "desc"
)

var (
	// ErrListProjectInventoriesParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectInventoriesParamsOrder = fmt.Errorf("invalid type for ListProjectInventoriesParamsOrder")

	stringToListProjectInventoriesParamsOrder = map[string]ListProjectInventoriesParamsOrder{
		"asc":  ListProjectInventoriesParamsOrderAsc,
		"desc": ListProjectInventoriesParamsOrderDesc,
	}
)

// ToListProjectInventoriesParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectInventoriesParamsOrder(val string) (ListProjectInventoriesParamsOrder, error) {
	if res, ok := stringToListProjectInventoriesParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectInventoriesParamsOrder(""), ErrListProjectInventoriesParamsOrder
}

// Defines values for ListProjectRepositoriesParamsOrder.
const (
	ListProjectRepositoriesParamsOrderAsc  ListProjectRepositoriesParamsOrder = "asc"
	ListProjectRepositoriesParamsOrderDesc ListProjectRepositoriesParamsOrder = "desc"
)

var (
	// ErrListProjectRepositoriesParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectRepositoriesParamsOrder = fmt.Errorf("invalid type for ListProjectRepositoriesParamsOrder")

	stringToListProjectRepositoriesParamsOrder = map[string]ListProjectRepositoriesParamsOrder{
		"asc":  ListProjectRepositoriesParamsOrderAsc,
		"desc": ListProjectRepositoriesParamsOrderDesc,
	}
)

// ToListProjectRepositoriesParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectRepositoriesParamsOrder(val string) (ListProjectRepositoriesParamsOrder, error) {
	if res, ok := stringToListProjectRepositoriesParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectRepositoriesParamsOrder(""), ErrListProjectRepositoriesParamsOrder
}

// Defines values for ListProjectRunnersParamsOrder.
const (
	ListProjectRunnersParamsOrderAsc  ListProjectRunnersParamsOrder = "asc"
	ListProjectRunnersParamsOrderDesc ListProjectRunnersParamsOrder = "desc"
)

var (
	// ErrListProjectRunnersParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectRunnersParamsOrder = fmt.Errorf("invalid type for ListProjectRunnersParamsOrder")

	stringToListProjectRunnersParamsOrder = map[string]ListProjectRunnersParamsOrder{
		"asc":  ListProjectRunnersParamsOrderAsc,
		"desc": ListProjectRunnersParamsOrderDesc,
	}
)

// ToListProjectRunnersParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectRunnersParamsOrder(val string) (ListProjectRunnersParamsOrder, error) {
	if res, ok := stringToListProjectRunnersParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectRunnersParamsOrder(""), ErrListProjectRunnersParamsOrder
}

// Defines values for ListProjectSchedulesParamsOrder.
const (
	ListProjectSchedulesParamsOrderAsc  ListProjectSchedulesParamsOrder = "asc"
	ListProjectSchedulesParamsOrderDesc ListProjectSchedulesParamsOrder = "desc"
)

var (
	// ErrListProjectSchedulesParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectSchedulesParamsOrder = fmt.Errorf("invalid type for ListProjectSchedulesParamsOrder")

	stringToListProjectSchedulesParamsOrder = map[string]ListProjectSchedulesParamsOrder{
		"asc":  ListProjectSchedulesParamsOrderAsc,
		"desc": ListProjectSchedulesParamsOrderDesc,
	}
)

// ToListProjectSchedulesParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectSchedulesParamsOrder(val string) (ListProjectSchedulesParamsOrder, error) {
	if res, ok := stringToListProjectSchedulesParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectSchedulesParamsOrder(""), ErrListProjectSchedulesParamsOrder
}

// Defines values for ListProjectTemplatesParamsOrder.
const (
	ListProjectTemplatesParamsOrderAsc  ListProjectTemplatesParamsOrder = "asc"
	ListProjectTemplatesParamsOrderDesc ListProjectTemplatesParamsOrder = "desc"
)

var (
	// ErrListProjectTemplatesParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectTemplatesParamsOrder = fmt.Errorf("invalid type for ListProjectTemplatesParamsOrder")

	stringToListProjectTemplatesParamsOrder = map[string]ListProjectTemplatesParamsOrder{
		"asc":  ListProjectTemplatesParamsOrderAsc,
		"desc": ListProjectTemplatesParamsOrderDesc,
	}
)

// ToListProjectTemplatesParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectTemplatesParamsOrder(val string) (ListProjectTemplatesParamsOrder, error) {
	if res, ok := stringToListProjectTemplatesParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectTemplatesParamsOrder(""), ErrListProjectTemplatesParamsOrder
}

// Defines values for ListProjectUsersParamsOrder.
const (
	ListProjectUsersParamsOrderAsc  ListProjectUsersParamsOrder = "asc"
	ListProjectUsersParamsOrderDesc ListProjectUsersParamsOrder = "desc"
)

var (
	// ErrListProjectUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListProjectUsersParamsOrder = fmt.Errorf("invalid type for ListProjectUsersParamsOrder")

	stringToListProjectUsersParamsOrder = map[string]ListProjectUsersParamsOrder{
		"asc":  ListProjectUsersParamsOrderAsc,
		"desc": ListProjectUsersParamsOrderDesc,
	}
)

// ToListProjectUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListProjectUsersParamsOrder(val string) (ListProjectUsersParamsOrder, error) {
	if res, ok := stringToListProjectUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListProjectUsersParamsOrder(""), ErrListProjectUsersParamsOrder
}

// Defines values for ListGlobalRunnersParamsOrder.
const (
	ListGlobalRunnersParamsOrderAsc  ListGlobalRunnersParamsOrder = "asc"
	ListGlobalRunnersParamsOrderDesc ListGlobalRunnersParamsOrder = "desc"
)

var (
	// ErrListGlobalRunnersParamsOrder defines an error if an invalid value gets mapped.
	ErrListGlobalRunnersParamsOrder = fmt.Errorf("invalid type for ListGlobalRunnersParamsOrder")

	stringToListGlobalRunnersParamsOrder = map[string]ListGlobalRunnersParamsOrder{
		"asc":  ListGlobalRunnersParamsOrderAsc,
		"desc": ListGlobalRunnersParamsOrderDesc,
	}
)

// ToListGlobalRunnersParamsOrder acts as a helper to map a string to the defined enum.
func ToListGlobalRunnersParamsOrder(val string) (ListGlobalRunnersParamsOrder, error) {
	if res, ok := stringToListGlobalRunnersParamsOrder[val]; ok {
		return res, nil
	}

	return ListGlobalRunnersParamsOrder(""), ErrListGlobalRunnersParamsOrder
}

// Defines values for ListUsersParamsOrder.
const (
	ListUsersParamsOrderAsc  ListUsersParamsOrder = "asc"
	ListUsersParamsOrderDesc ListUsersParamsOrder = "desc"
)

var (
	// ErrListUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListUsersParamsOrder = fmt.Errorf("invalid type for ListUsersParamsOrder")

	stringToListUsersParamsOrder = map[string]ListUsersParamsOrder{
		"asc":  ListUsersParamsOrderAsc,
		"desc": ListUsersParamsOrderDesc,
	}
)

// ToListUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListUsersParamsOrder(val string) (ListUsersParamsOrder, error) {
	if res, ok := stringToListUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListUsersParamsOrder(""), ErrListUsersParamsOrder
}

// Defines values for ListUserGroupsParamsOrder.
const (
	ListUserGroupsParamsOrderAsc  ListUserGroupsParamsOrder = "asc"
	ListUserGroupsParamsOrderDesc ListUserGroupsParamsOrder = "desc"
)

var (
	// ErrListUserGroupsParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserGroupsParamsOrder = fmt.Errorf("invalid type for ListUserGroupsParamsOrder")

	stringToListUserGroupsParamsOrder = map[string]ListUserGroupsParamsOrder{
		"asc":  ListUserGroupsParamsOrderAsc,
		"desc": ListUserGroupsParamsOrderDesc,
	}
)

// ToListUserGroupsParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserGroupsParamsOrder(val string) (ListUserGroupsParamsOrder, error) {
	if res, ok := stringToListUserGroupsParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserGroupsParamsOrder(""), ErrListUserGroupsParamsOrder
}

// Defines values for ListUserProjectsParamsOrder.
const (
	Asc  ListUserProjectsParamsOrder = "asc"
	Desc ListUserProjectsParamsOrder = "desc"
)

var (
	// ErrListUserProjectsParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserProjectsParamsOrder = fmt.Errorf("invalid type for ListUserProjectsParamsOrder")

	stringToListUserProjectsParamsOrder = map[string]ListUserProjectsParamsOrder{
		"asc":  Asc,
		"desc": Desc,
	}
)

// ToListUserProjectsParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserProjectsParamsOrder(val string) (ListUserProjectsParamsOrder, error) {
	if res, ok := stringToListUserProjectsParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserProjectsParamsOrder(""), ErrListUserProjectsParamsOrder
}

// AuthToken defines model for AuthToken.
type AuthToken struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
}

// AuthVerify defines model for AuthVerify.
type AuthVerify struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Username  *string    `json:"username,omitempty"`
}

// Credential Model to represent credential
type Credential struct {
	CreatedAt *time.Time      `json:"created_at,omitempty"`
	ID        *string         `json:"id,omitempty"`
	Kind      *CredentialKind `json:"kind,omitempty"`

	// Login Model to represent credential login
	Login     *CredentialLogin `json:"login,omitempty"`
	Name      *string          `json:"name,omitempty"`
	Override  *bool            `json:"override,omitempty"`
	ProjectID *string          `json:"project_id,omitempty"`

	// Shell Model to represent credential shell
	Shell     *CredentialShell `json:"shell,omitempty"`
	Slug      *string          `json:"slug,omitempty"`
	UpdatedAt *time.Time       `json:"updated_at,omitempty"`
}

// CredentialKind defines model for Credential.Kind.
type CredentialKind string

// CredentialLogin Model to represent credential login
type CredentialLogin struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CredentialShell Model to represent credential shell
type CredentialShell struct {
	Password   *string `json:"password,omitempty"`
	PrivateKey *string `json:"private_key,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// Environment Model to represent environment
type Environment struct {
	CreatedAt *time.Time           `json:"created_at,omitempty"`
	ID        *string              `json:"id,omitempty"`
	Name      *string              `json:"name,omitempty"`
	ProjectID *string              `json:"project_id,omitempty"`
	Secrets   *[]EnvironmentSecret `json:"secrets,omitempty"`
	Slug      *string              `json:"slug,omitempty"`
	UpdatedAt *time.Time           `json:"updated_at,omitempty"`
	Values    *[]EnvironmentValue  `json:"values,omitempty"`
}

// EnvironmentSecret Model to represent environment secret
type EnvironmentSecret struct {
	Content *string                `json:"content,omitempty"`
	ID      *string                `json:"id,omitempty"`
	Kind    *EnvironmentSecretKind `json:"kind,omitempty"`
	Name    *string                `json:"name,omitempty"`
}

// EnvironmentSecretKind defines model for EnvironmentSecret.Kind.
type EnvironmentSecretKind string

// EnvironmentValue Model to represent environment value
type EnvironmentValue struct {
	Content *string               `json:"content,omitempty"`
	ID      *string               `json:"id,omitempty"`
	Kind    *EnvironmentValueKind `json:"kind,omitempty"`
	Name    *string               `json:"name,omitempty"`
}

// EnvironmentValueKind defines model for EnvironmentValue.Kind.
type EnvironmentValueKind string

// Event Model to represent event
type Event struct {
	Action         *EventAction            `json:"action,omitempty"`
	Attrs          *map[string]interface{} `json:"attrs,omitempty"`
	CreatedAt      *time.Time              `json:"created_at,omitempty"`
	ObjectDisplay  *string                 `json:"object_display,omitempty"`
	ObjectID       *string                 `json:"object_id,omitempty"`
	ObjectType     *EventObjectType        `json:"object_type,omitempty"`
	ProjectDisplay *string                 `json:"project_display,omitempty"`
	ProjectID      *string                 `json:"project_id,omitempty"`
	UserDisplay    *string                 `json:"user_display,omitempty"`
	UserHandle     *string                 `json:"user_handle,omitempty"`
	UserID         *string                 `json:"user_id,omitempty"`
}

// EventAction defines model for Event.Action.
type EventAction string

// EventObjectType defines model for Event.ObjectType.
type EventObjectType string

// Execution Model to represent execution
type Execution struct {
	Branch      *string    `json:"branch,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Debug       *bool      `json:"debug,omitempty"`
	Environment *string    `json:"environment,omitempty"`
	ID          *string    `json:"id,omitempty"`
	Limit       *string    `json:"limit,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Path        *string    `json:"path,omitempty"`
	ProjectID   *string    `json:"project_id,omitempty"`
	Secret      *string    `json:"secret,omitempty"`
	Status      *string    `json:"status,omitempty"`

	// Template Model to represent template
	Template   *Template  `json:"template,omitempty"`
	TemplateID *string    `json:"template_id,omitempty"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`
}

// Group Model to represent group
type Group struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GroupProject Model to represent group project
type GroupProject struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group   *Group            `json:"group,omitempty"`
	GroupID string            `json:"group_id"`
	Perm    *GroupProjectPerm `json:"perm,omitempty"`

	// Project Model to represent project
	Project   *Project   `json:"project,omitempty"`
	ProjectID string     `json:"project_id"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GroupProjectPerm defines model for GroupProject.Perm.
type GroupProjectPerm string

// Inventory Model to represent inventory
type Inventory struct {
	// Become Model to represent credential
	Become    *Credential `json:"become,omitempty"`
	BecomeID  *string     `json:"become_id,omitempty"`
	Content   *string     `json:"content,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`

	// Credential Model to represent credential
	Credential   *Credential    `json:"credential,omitempty"`
	CredentialID *string        `json:"credential_id,omitempty"`
	ID           *string        `json:"id,omitempty"`
	Kind         *InventoryKind `json:"kind,omitempty"`
	Name         *string        `json:"name,omitempty"`
	ProjectID    *string        `json:"project_id,omitempty"`

	// Repository Model to represent repository
	Repository   *Repository `json:"repository,omitempty"`
	RepositoryID *string     `json:"repository_id,omitempty"`
	Slug         *string     `json:"slug,omitempty"`
	UpdatedAt    *time.Time  `json:"updated_at,omitempty"`
}

// InventoryKind defines model for Inventory.Kind.
type InventoryKind string

// Notification Generic response for errors and validations
type Notification struct {
	Errors  *[]Validation `json:"errors,omitempty"`
	Message *string       `json:"message,omitempty"`
	Status  *int          `json:"status,omitempty"`
}

// Output Model to represent output
type Output struct {
	Content   *string    `json:"content,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Execution Model to represent execution
	Execution   *Execution `json:"execution,omitempty"`
	ExecutionID *string    `json:"execution_id,omitempty"`
}

// Profile Model to represent profile
type Profile struct {
	Active    *bool          `json:"active,omitempty"`
	Admin     *bool          `json:"admin,omitempty"`
	Auths     *[]UserAuth    `json:"auths,omitempty"`
	CreatedAt *time.Time     `json:"created_at,omitempty"`
	Email     *string        `json:"email,omitempty"`
	Fullname  *string        `json:"fullname,omitempty"`
	Groups    *[]UserGroup   `json:"groups,omitempty"`
	ID        *string        `json:"id,omitempty"`
	Password  *string        `json:"password,omitempty"`
	Profile   *string        `json:"profile,omitempty"`
	Projects  *[]UserProject `json:"projects,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`
	Username  *string        `json:"username,omitempty"`
}

// Project Model to represent project
type Project struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Provider Model to represent auth provider
type Provider struct {
	Display *string `json:"display,omitempty"`
	Driver  *string `json:"driver,omitempty"`
	Icon    *string `json:"icon,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// Repository Model to represent repository
type Repository struct {
	Branch    *string    `json:"branch,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Credential Model to represent credential
	Credential   *Credential `json:"credential,omitempty"`
	CredentialID *string     `json:"credential_id,omitempty"`
	ID           *string     `json:"id,omitempty"`
	Name         *string     `json:"name,omitempty"`
	ProjectID    *string     `json:"project_id,omitempty"`
	Slug         *string     `json:"slug,omitempty"`
	UpdatedAt    *time.Time  `json:"updated_at,omitempty"`
	URL          *string     `json:"url,omitempty"`
}

// Runner Model to represent runner
type Runner struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`

	// Project Model to represent project
	Project   *Project   `json:"project,omitempty"`
	ProjectID *string    `json:"project_id,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	Token     *string    `json:"token,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Schedule Model to represent schedule
type Schedule struct {
	Active    *bool      `json:"active,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Cron      *string    `json:"cron,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	ProjectID *string    `json:"project_id,omitempty"`
	Slug      *string    `json:"slug,omitempty"`

	// Template Model to represent template
	Template   *Template  `json:"template,omitempty"`
	TemplateID *string    `json:"template_id,omitempty"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`
}

// Template Model to represent template
type Template struct {
	AllowOverride *bool      `json:"allow_override,omitempty"`
	Arguments     *string    `json:"arguments,omitempty"`
	Branch        *string    `json:"branch,omitempty"`
	CreatedAt     *time.Time `json:"created_at,omitempty"`
	Description   *string    `json:"description,omitempty"`

	// Environment Model to represent environment
	Environment   *Environment `json:"environment,omitempty"`
	EnvironmentID *string      `json:"environment_id,omitempty"`
	Executor      *string      `json:"executor,omitempty"`
	ID            *string      `json:"id,omitempty"`

	// Inventory Model to represent inventory
	Inventory   *Inventory `json:"inventory,omitempty"`
	InventoryID *string    `json:"inventory_id,omitempty"`
	Limit       *string    `json:"limit,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Path        *string    `json:"path,omitempty"`
	ProjectID   *string    `json:"project_id,omitempty"`

	// Repository Model to represent repository
	Repository   *Repository       `json:"repository,omitempty"`
	RepositoryID *string           `json:"repository_id,omitempty"`
	Slug         *string           `json:"slug,omitempty"`
	Surveys      *[]TemplateSurvey `json:"surveys,omitempty"`
	UpdatedAt    *time.Time        `json:"updated_at,omitempty"`
	Vaults       *[]TemplateVault  `json:"vaults,omitempty"`
}

// TemplateSurvey Model to represent template survey
type TemplateSurvey struct {
	Description *string             `json:"description,omitempty"`
	ID          *string             `json:"id,omitempty"`
	Kind        *TemplateSurveyKind `json:"kind,omitempty"`
	Name        *string             `json:"name,omitempty"`
	Required    *bool               `json:"required,omitempty"`
	Title       *string             `json:"title,omitempty"`
	Values      *[]TemplateValue    `json:"values,omitempty"`
}

// TemplateSurveyKind defines model for TemplateSurvey.Kind.
type TemplateSurveyKind string

// TemplateValue Model to represent template value
type TemplateValue struct {
	ID    *string `json:"id,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// TemplateVault Model to represent template vault
type TemplateVault struct {
	// Credential Model to represent credential
	Credential   *Credential        `json:"credential,omitempty"`
	CredentialID *string            `json:"credential_id,omitempty"`
	ID           *string            `json:"id,omitempty"`
	Kind         *TemplateVaultKind `json:"kind,omitempty"`
	Name         *string            `json:"name,omitempty"`
	Script       *string            `json:"script,omitempty"`
}

// TemplateVaultKind defines model for TemplateVault.Kind.
type TemplateVaultKind string

// User Model to represent user
type User struct {
	Active    *bool       `json:"active,omitempty"`
	Admin     *bool       `json:"admin,omitempty"`
	Auths     *[]UserAuth `json:"auths,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	Email     *string     `json:"email,omitempty"`
	Fullname  *string     `json:"fullname,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Password  *string     `json:"password,omitempty"`
	Profile   *string     `json:"profile,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Username  *string     `json:"username,omitempty"`
}

// UserAuth Model to represent user auth
type UserAuth struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
	Ref       *string    `json:"ref,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// UserGroup Model to represent user group
type UserGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group     *Group         `json:"group,omitempty"`
	GroupID   string         `json:"group_id"`
	Perm      *UserGroupPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserGroupPerm defines model for UserGroup.Perm.
type UserGroupPerm string

// UserProject Model to represent user project
type UserProject struct {
	CreatedAt *time.Time       `json:"created_at,omitempty"`
	Perm      *UserProjectPerm `json:"perm,omitempty"`

	// Project Model to represent project
	Project   *Project   `json:"project,omitempty"`
	ProjectID string     `json:"project_id"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserProjectPerm defines model for UserProject.Perm.
type UserProjectPerm string

// Validation General structure to show validation errors
type Validation struct {
	Field   *string `json:"field,omitempty"`
	Message *string `json:"message,omitempty"`
}

// AuthCodeParam defines model for AuthCodeParam.
type AuthCodeParam = string

// AuthProviderParam defines model for AuthProviderParam.
type AuthProviderParam = string

// AuthStateParam defines model for AuthStateParam.
type AuthStateParam = string

// CredentialID defines model for CredentialParam.
type CredentialID = string

// EnvironmentID defines model for EnvironmentParam.
type EnvironmentID = string

// ExecutionID defines model for ExecutionParam.
type ExecutionID = string

// GroupID defines model for GroupParam.
type GroupID = string

// InventoryID defines model for InventoryParam.
type InventoryID = string

// PagingLimitParam defines model for PagingLimitParam.
type PagingLimitParam = int

// PagingOffsetParam defines model for PagingOffsetParam.
type PagingOffsetParam = int

// ProjectID defines model for ProjectParam.
type ProjectID = string

// RepositoryID defines model for RepositoryParam.
type RepositoryID = string

// RunnerID defines model for RunnerParam.
type RunnerID = string

// ScheduleID defines model for ScheduleParam.
type ScheduleID = string

// SearchQueryParam defines model for SearchQueryParam.
type SearchQueryParam = string

// SecretID defines model for SecretParam.
type SecretID = string

// SortColumnParam defines model for SortColumnParam.
type SortColumnParam = string

// SortOrderParam defines model for SortOrderParam.
type SortOrderParam string

// SurveyID defines model for SurveyParam.
type SurveyID = string

// TemplateID defines model for TemplateParam.
type TemplateID = string

// UserID defines model for UserParam.
type UserID = string

// ValueID defines model for ValueParam.
type ValueID = string

// VaultID defines model for VaultParam.
type VaultID = string

// ActionFailedError Generic response for errors and validations
type ActionFailedError = Notification

// AlreadyAttachedError Generic response for errors and validations
type AlreadyAttachedError = Notification

// BadCredentialsError Generic response for errors and validations
type BadCredentialsError = Notification

// BadRequestError Generic response for errors and validations
type BadRequestError = Notification

// GlobalEventsResponse defines model for GlobalEventsResponse.
type GlobalEventsResponse struct {
	Events []Event `json:"events"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// GlobalRunnerResponse Model to represent runner
type GlobalRunnerResponse = Runner

// GlobalRunnersResponse defines model for GlobalRunnersResponse.
type GlobalRunnersResponse struct {
	Limit   int64    `json:"limit"`
	Offset  int64    `json:"offset"`
	Runners []Runner `json:"runners"`
	Total   int64    `json:"total"`
}

// GroupProjectsResponse defines model for GroupProjectsResponse.
type GroupProjectsResponse struct {
	// Group Model to represent group
	Group    *Group         `json:"group,omitempty"`
	Limit    int64          `json:"limit"`
	Offset   int64          `json:"offset"`
	Projects []GroupProject `json:"projects"`
	Total    int64          `json:"total"`
}

// GroupResponse Model to represent group
type GroupResponse = Group

// GroupUsersResponse defines model for GroupUsersResponse.
type GroupUsersResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`
	Users  []UserGroup `json:"users"`
}

// GroupsResponse defines model for GroupsResponse.
type GroupsResponse struct {
	Groups []Group `json:"groups"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// InternalServerError Generic response for errors and validations
type InternalServerError = Notification

// InvalidTokenError Generic response for errors and validations
type InvalidTokenError = Notification

// LoginResponse defines model for LoginResponse.
type LoginResponse = AuthToken

// NotAttachedError Generic response for errors and validations
type NotAttachedError = Notification

// NotAuthorizedError Generic response for errors and validations
type NotAuthorizedError = Notification

// NotFoundError Generic response for errors and validations
type NotFoundError = Notification

// ProfileResponse Model to represent profile
type ProfileResponse = Profile

// ProjectCredentialResponse Model to represent credential
type ProjectCredentialResponse = Credential

// ProjectCredentialsResponse defines model for ProjectCredentialsResponse.
type ProjectCredentialsResponse struct {
	Credentials []Credential `json:"credentials"`
	Limit       int64        `json:"limit"`
	Offset      int64        `json:"offset"`

	// Project Model to represent project
	Project *Project `json:"project,omitempty"`
	Total   int64    `json:"total"`
}

// ProjectEnvironmentResponse Model to represent environment
type ProjectEnvironmentResponse = Environment

// ProjectEnvironmentSecretResponse Model to represent environment secret
type ProjectEnvironmentSecretResponse = EnvironmentSecret

// ProjectEnvironmentValueResponse Model to represent environment value
type ProjectEnvironmentValueResponse = EnvironmentValue

// ProjectEnvironmentsResponse defines model for ProjectEnvironmentsResponse.
type ProjectEnvironmentsResponse struct {
	Environments []Environment `json:"environments"`
	Limit        int64         `json:"limit"`
	Offset       int64         `json:"offset"`

	// Project Model to represent project
	Project *Project `json:"project,omitempty"`
	Total   int64    `json:"total"`
}

// ProjectEventsResponse defines model for ProjectEventsResponse.
type ProjectEventsResponse struct {
	Events []Event `json:"events"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Project Model to represent project
	Project *Project `json:"project,omitempty"`
	Total   int64    `json:"total"`
}

// ProjectExecutionResponse Model to represent execution
type ProjectExecutionResponse = Execution

// ProjectExecutionsResponse defines model for ProjectExecutionsResponse.
type ProjectExecutionsResponse struct {
	Executions []Execution `json:"executions"`
	Limit      int64       `json:"limit"`
	Offset     int64       `json:"offset"`

	// Project Model to represent project
	Project *Project `json:"project,omitempty"`
	Total   int64    `json:"total"`
}

// ProjectGroupsResponse defines model for ProjectGroupsResponse.
type ProjectGroupsResponse struct {
	Groups []GroupProject `json:"groups"`
	Limit  int64          `json:"limit"`
	Offset int64          `json:"offset"`

	// Project Model to represent project
	Project *Project `json:"project,omitempty"`
	Total   int64    `json:"total"`
}

// ProjectInventoriesResponse defines model for ProjectInventoriesResponse.
type ProjectInventoriesResponse struct {
	Inventories []Inventory `json:"inventories"`
	Limit       int64       `json:"limit"`
	Offset      int64       `json:"offset"`

	// Project Model to represent project
	Project *Project `json:"project,omitempty"`
	Total   int64    `json:"total"`
}

// ProjectInventoryResponse Model to represent inventory
type ProjectInventoryResponse = Inventory

// ProjectOutputResponse defines model for ProjectOutputResponse.
type ProjectOutputResponse = []Output

// ProjectRepositoriesResponse defines model for ProjectRepositoriesResponse.
type ProjectRepositoriesResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Project Model to represent project
	Project      *Project     `json:"project,omitempty"`
	Repositories []Repository `json:"repositories"`
	Total        int64        `json:"total"`
}

// ProjectRepositoryResponse Model to represent repository
type ProjectRepositoryResponse = Repository

// ProjectResponse Model to represent project
type ProjectResponse = Project

// ProjectRunnerResponse Model to represent runner
type ProjectRunnerResponse = Runner

// ProjectRunnersResponse defines model for ProjectRunnersResponse.
type ProjectRunnersResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Project Model to represent project
	Project *Project `json:"project,omitempty"`
	Runners []Runner `json:"runners"`
	Total   int64    `json:"total"`
}

// ProjectScheduleResponse Model to represent schedule
type ProjectScheduleResponse = Schedule

// ProjectSchedulesResponse defines model for ProjectSchedulesResponse.
type ProjectSchedulesResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Project Model to represent project
	Project   *Project   `json:"project,omitempty"`
	Schedules []Schedule `json:"schedules"`
	Total     int64      `json:"total"`
}

// ProjectTemplateResponse Model to represent template
type ProjectTemplateResponse = Template

// ProjectTemplateSurveyResponse Model to represent template survey
type ProjectTemplateSurveyResponse = TemplateSurvey

// ProjectTemplateVaultResponse Model to represent template vault
type ProjectTemplateVaultResponse = TemplateVault

// ProjectTemplatesResponse defines model for ProjectTemplatesResponse.
type ProjectTemplatesResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Project Model to represent project
	Project   *Project   `json:"project,omitempty"`
	Templates []Template `json:"templates"`
	Total     int64      `json:"total"`
}

// ProjectUsersResponse defines model for ProjectUsersResponse.
type ProjectUsersResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Project Model to represent project
	Project *Project      `json:"project,omitempty"`
	Total   int64         `json:"total"`
	Users   []UserProject `json:"users"`
}

// ProjectsResponse defines model for ProjectsResponse.
type ProjectsResponse struct {
	Limit    int64     `json:"limit"`
	Offset   int64     `json:"offset"`
	Projects []Project `json:"projects"`
	Total    int64     `json:"total"`
}

// ProvidersResponse defines model for ProvidersResponse.
type ProvidersResponse struct {
	Providers []Provider `json:"providers"`
	Total     int64      `json:"total"`
}

// RefreshResponse defines model for RefreshResponse.
type RefreshResponse = AuthToken

// SuccessMessage Generic response for errors and validations
type SuccessMessage = Notification

// TokenResponse defines model for TokenResponse.
type TokenResponse = AuthToken

// UserGroupsResponse defines model for UserGroupsResponse.
type UserGroupsResponse struct {
	Groups []UserGroup `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserProjectsResponse defines model for UserProjectsResponse.
type UserProjectsResponse struct {
	Limit    int64         `json:"limit"`
	Offset   int64         `json:"offset"`
	Projects []UserProject `json:"projects"`
	Total    int64         `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserResponse Model to represent user
type UserResponse = User

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
	Users  []User `json:"users"`
}

// ValidationError Generic response for errors and validations
type ValidationError = Notification

// VerifyResponse defines model for VerifyResponse.
type VerifyResponse = AuthVerify

// CreateGlobalRunnerBody defines model for CreateGlobalRunnerBody.
type CreateGlobalRunnerBody struct {
	Name      *string `json:"name,omitempty"`
	ProjectID *string `json:"project_id,omitempty"`
	Slug      *string `json:"slug,omitempty"`
	Token     *string `json:"token,omitempty"`
}

// CreateGroupBody defines model for CreateGroupBody.
type CreateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// CreateProjectBody defines model for CreateProjectBody.
type CreateProjectBody struct {
	Demo *bool   `json:"demo,omitempty"`
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// CreateProjectCredentialBody defines model for CreateProjectCredentialBody.
type CreateProjectCredentialBody struct {
	Kind *string `json:"kind,omitempty"`

	// Login Model to represent credential login
	Login    *CredentialLogin `json:"login,omitempty"`
	Name     *string          `json:"name,omitempty"`
	Override *bool            `json:"override,omitempty"`

	// Shell Model to represent credential shell
	Shell *CredentialShell `json:"shell,omitempty"`
	Slug  *string          `json:"slug,omitempty"`
}

// CreateProjectEnvironmentBody defines model for CreateProjectEnvironmentBody.
type CreateProjectEnvironmentBody struct {
	Name    *string              `json:"name,omitempty"`
	Secrets *[]EnvironmentSecret `json:"secrets,omitempty"`
	Slug    *string              `json:"slug,omitempty"`
	Values  *[]EnvironmentValue  `json:"values,omitempty"`
}

// CreateProjectEnvironmentSecretBody defines model for CreateProjectEnvironmentSecretBody.
type CreateProjectEnvironmentSecretBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// CreateProjectEnvironmentValueBody defines model for CreateProjectEnvironmentValueBody.
type CreateProjectEnvironmentValueBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// CreateProjectExecutionBody defines model for CreateProjectExecutionBody.
type CreateProjectExecutionBody struct {
	Debug      *bool   `json:"debug,omitempty"`
	TemplateID *string `json:"template_id,omitempty"`
}

// CreateProjectInventoryBody defines model for CreateProjectInventoryBody.
type CreateProjectInventoryBody struct {
	BecomeID     *string `json:"become_id,omitempty"`
	Content      *string `json:"content,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	RepositoryID *string `json:"repository_id,omitempty"`
	Slug         *string `json:"slug,omitempty"`
}

// CreateProjectRepositoryBody defines model for CreateProjectRepositoryBody.
type CreateProjectRepositoryBody struct {
	Branch       *string `json:"branch,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Name         *string `json:"name,omitempty"`
	Slug         *string `json:"slug,omitempty"`
	URL          *string `json:"url,omitempty"`
}

// CreateProjectRunnerBody defines model for CreateProjectRunnerBody.
type CreateProjectRunnerBody struct {
	Name  *string `json:"name,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	Token *string `json:"token,omitempty"`
}

// CreateProjectScheduleBody defines model for CreateProjectScheduleBody.
type CreateProjectScheduleBody struct {
	Active     *bool   `json:"active,omitempty"`
	Cron       *string `json:"cron,omitempty"`
	Name       *string `json:"name,omitempty"`
	Slug       *string `json:"slug,omitempty"`
	TemplateID *string `json:"template_id,omitempty"`
}

// CreateProjectTemplateBody defines model for CreateProjectTemplateBody.
type CreateProjectTemplateBody struct {
	AllowOverride *bool             `json:"allow_override,omitempty"`
	Arguments     *string           `json:"arguments,omitempty"`
	Branch        *string           `json:"branch,omitempty"`
	Description   *string           `json:"description,omitempty"`
	EnvironmentID *string           `json:"environment_id,omitempty"`
	Executor      *string           `json:"executor,omitempty"`
	InventoryID   *string           `json:"inventory_id,omitempty"`
	Limit         *string           `json:"limit,omitempty"`
	Name          *string           `json:"name,omitempty"`
	Path          *string           `json:"path,omitempty"`
	RepositoryID  *string           `json:"repository_id,omitempty"`
	Slug          *string           `json:"slug,omitempty"`
	Surveys       *[]TemplateSurvey `json:"surveys,omitempty"`
	Vaults        *[]TemplateVault  `json:"vaults,omitempty"`
}

// CreateProjectTemplateSurveyBody defines model for CreateProjectTemplateSurveyBody.
type CreateProjectTemplateSurveyBody struct {
	Description *string          `json:"description,omitempty"`
	Kind        *string          `json:"kind,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Required    *bool            `json:"required,omitempty"`
	Title       *string          `json:"title,omitempty"`
	Values      *[]TemplateValue `json:"values,omitempty"`
}

// CreateProjectTemplateVaultBody defines model for CreateProjectTemplateVaultBody.
type CreateProjectTemplateVaultBody struct {
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	Script       *string `json:"script,omitempty"`
}

// CreateUserBody defines model for CreateUserBody.
type CreateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// GroupProjectDropBody defines model for GroupProjectDropBody.
type GroupProjectDropBody struct {
	Project string `json:"project"`
}

// GroupProjectPermBody defines model for GroupProjectPermBody.
type GroupProjectPermBody struct {
	Perm    string `json:"perm"`
	Project string `json:"project"`
}

// GroupUserDropBody defines model for GroupUserDropBody.
type GroupUserDropBody struct {
	User string `json:"user"`
}

// GroupUserPermBody defines model for GroupUserPermBody.
type GroupUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// LoginAuthBody defines model for LoginAuthBody.
type LoginAuthBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// ProjectGroupDropBody defines model for ProjectGroupDropBody.
type ProjectGroupDropBody struct {
	Group string `json:"group"`
}

// ProjectGroupPermBody defines model for ProjectGroupPermBody.
type ProjectGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// ProjectUserDropBody defines model for ProjectUserDropBody.
type ProjectUserDropBody struct {
	User string `json:"user"`
}

// ProjectUserPermBody defines model for ProjectUserPermBody.
type ProjectUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// RedirectAuthBody defines model for RedirectAuthBody.
type RedirectAuthBody struct {
	Token string `json:"token"`
}

// UpdateGlobalRunnerBody defines model for UpdateGlobalRunnerBody.
type UpdateGlobalRunnerBody struct {
	Name      *string `json:"name,omitempty"`
	ProjectID *string `json:"project_id,omitempty"`
	Slug      *string `json:"slug,omitempty"`
	Token     *string `json:"token,omitempty"`
}

// UpdateGroupBody defines model for UpdateGroupBody.
type UpdateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateProfileBody defines model for UpdateProfileBody.
type UpdateProfileBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateProjectBody defines model for UpdateProjectBody.
type UpdateProjectBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateProjectCredentialBody defines model for UpdateProjectCredentialBody.
type UpdateProjectCredentialBody struct {
	Kind *string `json:"kind,omitempty"`

	// Login Model to represent credential login
	Login    *CredentialLogin `json:"login,omitempty"`
	Name     *string          `json:"name,omitempty"`
	Override *bool            `json:"override,omitempty"`

	// Shell Model to represent credential shell
	Shell *CredentialShell `json:"shell,omitempty"`
	Slug  *string          `json:"slug,omitempty"`
}

// UpdateProjectEnvironmentBody defines model for UpdateProjectEnvironmentBody.
type UpdateProjectEnvironmentBody struct {
	Name    *string              `json:"name,omitempty"`
	Secrets *[]EnvironmentSecret `json:"secrets,omitempty"`
	Slug    *string              `json:"slug,omitempty"`
	Values  *[]EnvironmentValue  `json:"values,omitempty"`
}

// UpdateProjectEnvironmentSecretBody defines model for UpdateProjectEnvironmentSecretBody.
type UpdateProjectEnvironmentSecretBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// UpdateProjectEnvironmentValueBody defines model for UpdateProjectEnvironmentValueBody.
type UpdateProjectEnvironmentValueBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// UpdateProjectInventoryBody defines model for UpdateProjectInventoryBody.
type UpdateProjectInventoryBody struct {
	BecomeID     *string `json:"become_id,omitempty"`
	Content      *string `json:"content,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	RepositoryID *string `json:"repository_id,omitempty"`
	Slug         *string `json:"slug,omitempty"`
}

// UpdateProjectRepositoryBody defines model for UpdateProjectRepositoryBody.
type UpdateProjectRepositoryBody struct {
	Branch       *string `json:"branch,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Name         *string `json:"name,omitempty"`
	Slug         *string `json:"slug,omitempty"`
	URL          *string `json:"url,omitempty"`
}

// UpdateProjectRunnerBody defines model for UpdateProjectRunnerBody.
type UpdateProjectRunnerBody struct {
	Name  *string `json:"name,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	Token *string `json:"token,omitempty"`
}

// UpdateProjectScheduleBody defines model for UpdateProjectScheduleBody.
type UpdateProjectScheduleBody struct {
	Active     *bool   `json:"active,omitempty"`
	Cron       *string `json:"cron,omitempty"`
	Name       *string `json:"name,omitempty"`
	Slug       *string `json:"slug,omitempty"`
	TemplateID *string `json:"template_id,omitempty"`
}

// UpdateProjectTemplateBody defines model for UpdateProjectTemplateBody.
type UpdateProjectTemplateBody struct {
	AllowOverride *bool             `json:"allow_override,omitempty"`
	Arguments     *string           `json:"arguments,omitempty"`
	Branch        *string           `json:"branch,omitempty"`
	Description   *string           `json:"description,omitempty"`
	EnvironmentID *string           `json:"environment_id,omitempty"`
	InventoryID   *string           `json:"inventory_id,omitempty"`
	Limit         *string           `json:"limit,omitempty"`
	Name          *string           `json:"name,omitempty"`
	Path          *string           `json:"path,omitempty"`
	RepositoryID  *string           `json:"repository_id,omitempty"`
	Slug          *string           `json:"slug,omitempty"`
	Surveys       *[]TemplateSurvey `json:"surveys,omitempty"`
	Vaults        *[]TemplateVault  `json:"vaults,omitempty"`
}

// UpdateProjectTemplateSurveyBody defines model for UpdateProjectTemplateSurveyBody.
type UpdateProjectTemplateSurveyBody struct {
	Description *string          `json:"description,omitempty"`
	Kind        *string          `json:"kind,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Required    *bool            `json:"required,omitempty"`
	Title       *string          `json:"title,omitempty"`
	Values      *[]TemplateValue `json:"values,omitempty"`
}

// UpdateProjectTemplateVaultBody defines model for UpdateProjectTemplateVaultBody.
type UpdateProjectTemplateVaultBody struct {
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	Script       *string `json:"script,omitempty"`
}

// UpdateUserBody defines model for UpdateUserBody.
type UpdateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserGroupDropBody defines model for UserGroupDropBody.
type UserGroupDropBody struct {
	Group string `json:"group"`
}

// UserGroupPermBody defines model for UserGroupPermBody.
type UserGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// UserProjectDropBody defines model for UserProjectDropBody.
type UserProjectDropBody struct {
	Project string `json:"project"`
}

// UserProjectPermBody defines model for UserProjectPermBody.
type UserProjectPermBody struct {
	Perm    string `json:"perm"`
	Project string `json:"project"`
}

// LoginAuthJSONBody defines parameters for LoginAuth.
type LoginAuthJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// RedirectAuthJSONBody defines parameters for RedirectAuth.
type RedirectAuthJSONBody struct {
	Token string `json:"token"`
}

// CallbackProviderParams defines parameters for CallbackProvider.
type CallbackProviderParams struct {
	// State Auth state
	State *AuthStateParam `form:"state,omitempty" json:"state,omitempty"`

	// Code Auth code
	Code *AuthCodeParam `form:"code,omitempty" json:"code,omitempty"`
}

// ListGlobalEventsParams defines parameters for ListGlobalEvents.
type ListGlobalEventsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupsParamsOrder defines parameters for ListGroups.
type ListGroupsParamsOrder string

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// DeleteGroupFromProjectJSONBody defines parameters for DeleteGroupFromProject.
type DeleteGroupFromProjectJSONBody struct {
	Project string `json:"project"`
}

// ListGroupProjectsParams defines parameters for ListGroupProjects.
type ListGroupProjectsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupProjectsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupProjectsParamsOrder defines parameters for ListGroupProjects.
type ListGroupProjectsParamsOrder string

// AttachGroupToProjectJSONBody defines parameters for AttachGroupToProject.
type AttachGroupToProjectJSONBody struct {
	Perm    string `json:"perm"`
	Project string `json:"project"`
}

// PermitGroupProjectJSONBody defines parameters for PermitGroupProject.
type PermitGroupProjectJSONBody struct {
	Perm    string `json:"perm"`
	Project string `json:"project"`
}

// DeleteGroupFromUserJSONBody defines parameters for DeleteGroupFromUser.
type DeleteGroupFromUserJSONBody struct {
	User string `json:"user"`
}

// ListGroupUsersParams defines parameters for ListGroupUsers.
type ListGroupUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupUsersParamsOrder defines parameters for ListGroupUsers.
type ListGroupUsersParamsOrder string

// AttachGroupToUserJSONBody defines parameters for AttachGroupToUser.
type AttachGroupToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitGroupUserJSONBody defines parameters for PermitGroupUser.
type PermitGroupUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// UpdateProfileJSONBody defines parameters for UpdateProfile.
type UpdateProfileJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectsParamsOrder defines parameters for ListProjects.
type ListProjectsParamsOrder string

// CreateProjectJSONBody defines parameters for CreateProject.
type CreateProjectJSONBody struct {
	Demo *bool   `json:"demo,omitempty"`
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateProjectJSONBody defines parameters for UpdateProject.
type UpdateProjectJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// ListProjectCredentialsParams defines parameters for ListProjectCredentials.
type ListProjectCredentialsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectCredentialsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectCredentialsParamsOrder defines parameters for ListProjectCredentials.
type ListProjectCredentialsParamsOrder string

// CreateProjectCredentialJSONBody defines parameters for CreateProjectCredential.
type CreateProjectCredentialJSONBody struct {
	Kind *string `json:"kind,omitempty"`

	// Login Model to represent credential login
	Login    *CredentialLogin `json:"login,omitempty"`
	Name     *string          `json:"name,omitempty"`
	Override *bool            `json:"override,omitempty"`

	// Shell Model to represent credential shell
	Shell *CredentialShell `json:"shell,omitempty"`
	Slug  *string          `json:"slug,omitempty"`
}

// UpdateProjectCredentialJSONBody defines parameters for UpdateProjectCredential.
type UpdateProjectCredentialJSONBody struct {
	Kind *string `json:"kind,omitempty"`

	// Login Model to represent credential login
	Login    *CredentialLogin `json:"login,omitempty"`
	Name     *string          `json:"name,omitempty"`
	Override *bool            `json:"override,omitempty"`

	// Shell Model to represent credential shell
	Shell *CredentialShell `json:"shell,omitempty"`
	Slug  *string          `json:"slug,omitempty"`
}

// ListProjectEnvironmentsParams defines parameters for ListProjectEnvironments.
type ListProjectEnvironmentsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectEnvironmentsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectEnvironmentsParamsOrder defines parameters for ListProjectEnvironments.
type ListProjectEnvironmentsParamsOrder string

// CreateProjectEnvironmentJSONBody defines parameters for CreateProjectEnvironment.
type CreateProjectEnvironmentJSONBody struct {
	Name    *string              `json:"name,omitempty"`
	Secrets *[]EnvironmentSecret `json:"secrets,omitempty"`
	Slug    *string              `json:"slug,omitempty"`
	Values  *[]EnvironmentValue  `json:"values,omitempty"`
}

// UpdateProjectEnvironmentJSONBody defines parameters for UpdateProjectEnvironment.
type UpdateProjectEnvironmentJSONBody struct {
	Name    *string              `json:"name,omitempty"`
	Secrets *[]EnvironmentSecret `json:"secrets,omitempty"`
	Slug    *string              `json:"slug,omitempty"`
	Values  *[]EnvironmentValue  `json:"values,omitempty"`
}

// CreateProjectEnvironmentSecretJSONBody defines parameters for CreateProjectEnvironmentSecret.
type CreateProjectEnvironmentSecretJSONBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// UpdateProjectEnvironmentSecretJSONBody defines parameters for UpdateProjectEnvironmentSecret.
type UpdateProjectEnvironmentSecretJSONBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// CreateProjectEnvironmentValueJSONBody defines parameters for CreateProjectEnvironmentValue.
type CreateProjectEnvironmentValueJSONBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// UpdateProjectEnvironmentValueJSONBody defines parameters for UpdateProjectEnvironmentValue.
type UpdateProjectEnvironmentValueJSONBody struct {
	Content *string `json:"content,omitempty"`
	Kind    *string `json:"kind,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// ListProjectEventsParams defines parameters for ListProjectEvents.
type ListProjectEventsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectExecutionsParams defines parameters for ListProjectExecutions.
type ListProjectExecutionsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectExecutionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectExecutionsParamsOrder defines parameters for ListProjectExecutions.
type ListProjectExecutionsParamsOrder string

// CreateProjectExecutionJSONBody defines parameters for CreateProjectExecution.
type CreateProjectExecutionJSONBody struct {
	Debug      *bool   `json:"debug,omitempty"`
	TemplateID *string `json:"template_id,omitempty"`
}

// DeleteProjectFromGroupJSONBody defines parameters for DeleteProjectFromGroup.
type DeleteProjectFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListProjectGroupsParams defines parameters for ListProjectGroups.
type ListProjectGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectGroupsParamsOrder defines parameters for ListProjectGroups.
type ListProjectGroupsParamsOrder string

// AttachProjectToGroupJSONBody defines parameters for AttachProjectToGroup.
type AttachProjectToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitProjectGroupJSONBody defines parameters for PermitProjectGroup.
type PermitProjectGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// ListProjectInventoriesParams defines parameters for ListProjectInventories.
type ListProjectInventoriesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectInventoriesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectInventoriesParamsOrder defines parameters for ListProjectInventories.
type ListProjectInventoriesParamsOrder string

// CreateProjectInventoryJSONBody defines parameters for CreateProjectInventory.
type CreateProjectInventoryJSONBody struct {
	BecomeID     *string `json:"become_id,omitempty"`
	Content      *string `json:"content,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	RepositoryID *string `json:"repository_id,omitempty"`
	Slug         *string `json:"slug,omitempty"`
}

// UpdateProjectInventoryJSONBody defines parameters for UpdateProjectInventory.
type UpdateProjectInventoryJSONBody struct {
	BecomeID     *string `json:"become_id,omitempty"`
	Content      *string `json:"content,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	RepositoryID *string `json:"repository_id,omitempty"`
	Slug         *string `json:"slug,omitempty"`
}

// ListProjectRepositoriesParams defines parameters for ListProjectRepositories.
type ListProjectRepositoriesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectRepositoriesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectRepositoriesParamsOrder defines parameters for ListProjectRepositories.
type ListProjectRepositoriesParamsOrder string

// CreateProjectRepositoryJSONBody defines parameters for CreateProjectRepository.
type CreateProjectRepositoryJSONBody struct {
	Branch       *string `json:"branch,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Name         *string `json:"name,omitempty"`
	Slug         *string `json:"slug,omitempty"`
	URL          *string `json:"url,omitempty"`
}

// UpdateProjectRepositoryJSONBody defines parameters for UpdateProjectRepository.
type UpdateProjectRepositoryJSONBody struct {
	Branch       *string `json:"branch,omitempty"`
	CredentialID *string `json:"credential_id,omitempty"`
	Name         *string `json:"name,omitempty"`
	Slug         *string `json:"slug,omitempty"`
	URL          *string `json:"url,omitempty"`
}

// ListProjectRunnersParams defines parameters for ListProjectRunners.
type ListProjectRunnersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectRunnersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectRunnersParamsOrder defines parameters for ListProjectRunners.
type ListProjectRunnersParamsOrder string

// CreateProjectRunnerJSONBody defines parameters for CreateProjectRunner.
type CreateProjectRunnerJSONBody struct {
	Name  *string `json:"name,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	Token *string `json:"token,omitempty"`
}

// UpdateProjectRunnerJSONBody defines parameters for UpdateProjectRunner.
type UpdateProjectRunnerJSONBody struct {
	Name  *string `json:"name,omitempty"`
	Slug  *string `json:"slug,omitempty"`
	Token *string `json:"token,omitempty"`
}

// ListProjectSchedulesParams defines parameters for ListProjectSchedules.
type ListProjectSchedulesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectSchedulesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectSchedulesParamsOrder defines parameters for ListProjectSchedules.
type ListProjectSchedulesParamsOrder string

// CreateProjectScheduleJSONBody defines parameters for CreateProjectSchedule.
type CreateProjectScheduleJSONBody struct {
	Active     *bool   `json:"active,omitempty"`
	Cron       *string `json:"cron,omitempty"`
	Name       *string `json:"name,omitempty"`
	Slug       *string `json:"slug,omitempty"`
	TemplateID *string `json:"template_id,omitempty"`
}

// UpdateProjectScheduleJSONBody defines parameters for UpdateProjectSchedule.
type UpdateProjectScheduleJSONBody struct {
	Active     *bool   `json:"active,omitempty"`
	Cron       *string `json:"cron,omitempty"`
	Name       *string `json:"name,omitempty"`
	Slug       *string `json:"slug,omitempty"`
	TemplateID *string `json:"template_id,omitempty"`
}

// ListProjectTemplatesParams defines parameters for ListProjectTemplates.
type ListProjectTemplatesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectTemplatesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectTemplatesParamsOrder defines parameters for ListProjectTemplates.
type ListProjectTemplatesParamsOrder string

// CreateProjectTemplateJSONBody defines parameters for CreateProjectTemplate.
type CreateProjectTemplateJSONBody struct {
	AllowOverride *bool             `json:"allow_override,omitempty"`
	Arguments     *string           `json:"arguments,omitempty"`
	Branch        *string           `json:"branch,omitempty"`
	Description   *string           `json:"description,omitempty"`
	EnvironmentID *string           `json:"environment_id,omitempty"`
	Executor      *string           `json:"executor,omitempty"`
	InventoryID   *string           `json:"inventory_id,omitempty"`
	Limit         *string           `json:"limit,omitempty"`
	Name          *string           `json:"name,omitempty"`
	Path          *string           `json:"path,omitempty"`
	RepositoryID  *string           `json:"repository_id,omitempty"`
	Slug          *string           `json:"slug,omitempty"`
	Surveys       *[]TemplateSurvey `json:"surveys,omitempty"`
	Vaults        *[]TemplateVault  `json:"vaults,omitempty"`
}

// UpdateProjectTemplateJSONBody defines parameters for UpdateProjectTemplate.
type UpdateProjectTemplateJSONBody struct {
	AllowOverride *bool             `json:"allow_override,omitempty"`
	Arguments     *string           `json:"arguments,omitempty"`
	Branch        *string           `json:"branch,omitempty"`
	Description   *string           `json:"description,omitempty"`
	EnvironmentID *string           `json:"environment_id,omitempty"`
	InventoryID   *string           `json:"inventory_id,omitempty"`
	Limit         *string           `json:"limit,omitempty"`
	Name          *string           `json:"name,omitempty"`
	Path          *string           `json:"path,omitempty"`
	RepositoryID  *string           `json:"repository_id,omitempty"`
	Slug          *string           `json:"slug,omitempty"`
	Surveys       *[]TemplateSurvey `json:"surveys,omitempty"`
	Vaults        *[]TemplateVault  `json:"vaults,omitempty"`
}

// CreateProjectTemplateSurveyJSONBody defines parameters for CreateProjectTemplateSurvey.
type CreateProjectTemplateSurveyJSONBody struct {
	Description *string          `json:"description,omitempty"`
	Kind        *string          `json:"kind,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Required    *bool            `json:"required,omitempty"`
	Title       *string          `json:"title,omitempty"`
	Values      *[]TemplateValue `json:"values,omitempty"`
}

// UpdateProjectTemplateSurveyJSONBody defines parameters for UpdateProjectTemplateSurvey.
type UpdateProjectTemplateSurveyJSONBody struct {
	Description *string          `json:"description,omitempty"`
	Kind        *string          `json:"kind,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Required    *bool            `json:"required,omitempty"`
	Title       *string          `json:"title,omitempty"`
	Values      *[]TemplateValue `json:"values,omitempty"`
}

// CreateProjectTemplateVaultJSONBody defines parameters for CreateProjectTemplateVault.
type CreateProjectTemplateVaultJSONBody struct {
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	Script       *string `json:"script,omitempty"`
}

// UpdateProjectTemplateVaultJSONBody defines parameters for UpdateProjectTemplateVault.
type UpdateProjectTemplateVaultJSONBody struct {
	CredentialID *string `json:"credential_id,omitempty"`
	Kind         *string `json:"kind,omitempty"`
	Name         *string `json:"name,omitempty"`
	Script       *string `json:"script,omitempty"`
}

// DeleteProjectFromUserJSONBody defines parameters for DeleteProjectFromUser.
type DeleteProjectFromUserJSONBody struct {
	User string `json:"user"`
}

// ListProjectUsersParams defines parameters for ListProjectUsers.
type ListProjectUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListProjectUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListProjectUsersParamsOrder defines parameters for ListProjectUsers.
type ListProjectUsersParamsOrder string

// AttachProjectToUserJSONBody defines parameters for AttachProjectToUser.
type AttachProjectToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitProjectUserJSONBody defines parameters for PermitProjectUser.
type PermitProjectUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// ListGlobalRunnersParams defines parameters for ListGlobalRunners.
type ListGlobalRunnersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGlobalRunnersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGlobalRunnersParamsOrder defines parameters for ListGlobalRunners.
type ListGlobalRunnersParamsOrder string

// CreateGlobalRunnerJSONBody defines parameters for CreateGlobalRunner.
type CreateGlobalRunnerJSONBody struct {
	Name      *string `json:"name,omitempty"`
	ProjectID *string `json:"project_id,omitempty"`
	Slug      *string `json:"slug,omitempty"`
	Token     *string `json:"token,omitempty"`
}

// UpdateGlobalRunnerJSONBody defines parameters for UpdateGlobalRunner.
type UpdateGlobalRunnerJSONBody struct {
	Name      *string `json:"name,omitempty"`
	ProjectID *string `json:"project_id,omitempty"`
	Slug      *string `json:"slug,omitempty"`
	Token     *string `json:"token,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUsersParamsOrder defines parameters for ListUsers.
type ListUsersParamsOrder string

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// DeleteUserFromGroupJSONBody defines parameters for DeleteUserFromGroup.
type DeleteUserFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserGroupsParamsOrder defines parameters for ListUserGroups.
type ListUserGroupsParamsOrder string

// AttachUserToGroupJSONBody defines parameters for AttachUserToGroup.
type AttachUserToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitUserGroupJSONBody defines parameters for PermitUserGroup.
type PermitUserGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeleteUserFromProjectJSONBody defines parameters for DeleteUserFromProject.
type DeleteUserFromProjectJSONBody struct {
	Project string `json:"project"`
}

// ListUserProjectsParams defines parameters for ListUserProjects.
type ListUserProjectsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserProjectsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserProjectsParamsOrder defines parameters for ListUserProjects.
type ListUserProjectsParamsOrder string

// AttachUserToProjectJSONBody defines parameters for AttachUserToProject.
type AttachUserToProjectJSONBody struct {
	Perm    string `json:"perm"`
	Project string `json:"project"`
}

// PermitUserProjectJSONBody defines parameters for PermitUserProject.
type PermitUserProjectJSONBody struct {
	Perm    string `json:"perm"`
	Project string `json:"project"`
}

// LoginAuthJSONRequestBody defines body for LoginAuth for application/json ContentType.
type LoginAuthJSONRequestBody LoginAuthJSONBody

// RedirectAuthJSONRequestBody defines body for RedirectAuth for application/json ContentType.
type RedirectAuthJSONRequestBody RedirectAuthJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// DeleteGroupFromProjectJSONRequestBody defines body for DeleteGroupFromProject for application/json ContentType.
type DeleteGroupFromProjectJSONRequestBody DeleteGroupFromProjectJSONBody

// AttachGroupToProjectJSONRequestBody defines body for AttachGroupToProject for application/json ContentType.
type AttachGroupToProjectJSONRequestBody AttachGroupToProjectJSONBody

// PermitGroupProjectJSONRequestBody defines body for PermitGroupProject for application/json ContentType.
type PermitGroupProjectJSONRequestBody PermitGroupProjectJSONBody

// DeleteGroupFromUserJSONRequestBody defines body for DeleteGroupFromUser for application/json ContentType.
type DeleteGroupFromUserJSONRequestBody DeleteGroupFromUserJSONBody

// AttachGroupToUserJSONRequestBody defines body for AttachGroupToUser for application/json ContentType.
type AttachGroupToUserJSONRequestBody AttachGroupToUserJSONBody

// PermitGroupUserJSONRequestBody defines body for PermitGroupUser for application/json ContentType.
type PermitGroupUserJSONRequestBody PermitGroupUserJSONBody

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody UpdateProfileJSONBody

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody CreateProjectJSONBody

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdateProjectJSONBody

// CreateProjectCredentialJSONRequestBody defines body for CreateProjectCredential for application/json ContentType.
type CreateProjectCredentialJSONRequestBody CreateProjectCredentialJSONBody

// UpdateProjectCredentialJSONRequestBody defines body for UpdateProjectCredential for application/json ContentType.
type UpdateProjectCredentialJSONRequestBody UpdateProjectCredentialJSONBody

// CreateProjectEnvironmentJSONRequestBody defines body for CreateProjectEnvironment for application/json ContentType.
type CreateProjectEnvironmentJSONRequestBody CreateProjectEnvironmentJSONBody

// UpdateProjectEnvironmentJSONRequestBody defines body for UpdateProjectEnvironment for application/json ContentType.
type UpdateProjectEnvironmentJSONRequestBody UpdateProjectEnvironmentJSONBody

// CreateProjectEnvironmentSecretJSONRequestBody defines body for CreateProjectEnvironmentSecret for application/json ContentType.
type CreateProjectEnvironmentSecretJSONRequestBody CreateProjectEnvironmentSecretJSONBody

// UpdateProjectEnvironmentSecretJSONRequestBody defines body for UpdateProjectEnvironmentSecret for application/json ContentType.
type UpdateProjectEnvironmentSecretJSONRequestBody UpdateProjectEnvironmentSecretJSONBody

// CreateProjectEnvironmentValueJSONRequestBody defines body for CreateProjectEnvironmentValue for application/json ContentType.
type CreateProjectEnvironmentValueJSONRequestBody CreateProjectEnvironmentValueJSONBody

// UpdateProjectEnvironmentValueJSONRequestBody defines body for UpdateProjectEnvironmentValue for application/json ContentType.
type UpdateProjectEnvironmentValueJSONRequestBody UpdateProjectEnvironmentValueJSONBody

// CreateProjectExecutionJSONRequestBody defines body for CreateProjectExecution for application/json ContentType.
type CreateProjectExecutionJSONRequestBody CreateProjectExecutionJSONBody

// DeleteProjectFromGroupJSONRequestBody defines body for DeleteProjectFromGroup for application/json ContentType.
type DeleteProjectFromGroupJSONRequestBody DeleteProjectFromGroupJSONBody

// AttachProjectToGroupJSONRequestBody defines body for AttachProjectToGroup for application/json ContentType.
type AttachProjectToGroupJSONRequestBody AttachProjectToGroupJSONBody

// PermitProjectGroupJSONRequestBody defines body for PermitProjectGroup for application/json ContentType.
type PermitProjectGroupJSONRequestBody PermitProjectGroupJSONBody

// CreateProjectInventoryJSONRequestBody defines body for CreateProjectInventory for application/json ContentType.
type CreateProjectInventoryJSONRequestBody CreateProjectInventoryJSONBody

// UpdateProjectInventoryJSONRequestBody defines body for UpdateProjectInventory for application/json ContentType.
type UpdateProjectInventoryJSONRequestBody UpdateProjectInventoryJSONBody

// CreateProjectRepositoryJSONRequestBody defines body for CreateProjectRepository for application/json ContentType.
type CreateProjectRepositoryJSONRequestBody CreateProjectRepositoryJSONBody

// UpdateProjectRepositoryJSONRequestBody defines body for UpdateProjectRepository for application/json ContentType.
type UpdateProjectRepositoryJSONRequestBody UpdateProjectRepositoryJSONBody

// CreateProjectRunnerJSONRequestBody defines body for CreateProjectRunner for application/json ContentType.
type CreateProjectRunnerJSONRequestBody CreateProjectRunnerJSONBody

// UpdateProjectRunnerJSONRequestBody defines body for UpdateProjectRunner for application/json ContentType.
type UpdateProjectRunnerJSONRequestBody UpdateProjectRunnerJSONBody

// CreateProjectScheduleJSONRequestBody defines body for CreateProjectSchedule for application/json ContentType.
type CreateProjectScheduleJSONRequestBody CreateProjectScheduleJSONBody

// UpdateProjectScheduleJSONRequestBody defines body for UpdateProjectSchedule for application/json ContentType.
type UpdateProjectScheduleJSONRequestBody UpdateProjectScheduleJSONBody

// CreateProjectTemplateJSONRequestBody defines body for CreateProjectTemplate for application/json ContentType.
type CreateProjectTemplateJSONRequestBody CreateProjectTemplateJSONBody

// UpdateProjectTemplateJSONRequestBody defines body for UpdateProjectTemplate for application/json ContentType.
type UpdateProjectTemplateJSONRequestBody UpdateProjectTemplateJSONBody

// CreateProjectTemplateSurveyJSONRequestBody defines body for CreateProjectTemplateSurvey for application/json ContentType.
type CreateProjectTemplateSurveyJSONRequestBody CreateProjectTemplateSurveyJSONBody

// UpdateProjectTemplateSurveyJSONRequestBody defines body for UpdateProjectTemplateSurvey for application/json ContentType.
type UpdateProjectTemplateSurveyJSONRequestBody UpdateProjectTemplateSurveyJSONBody

// CreateProjectTemplateVaultJSONRequestBody defines body for CreateProjectTemplateVault for application/json ContentType.
type CreateProjectTemplateVaultJSONRequestBody CreateProjectTemplateVaultJSONBody

// UpdateProjectTemplateVaultJSONRequestBody defines body for UpdateProjectTemplateVault for application/json ContentType.
type UpdateProjectTemplateVaultJSONRequestBody UpdateProjectTemplateVaultJSONBody

// DeleteProjectFromUserJSONRequestBody defines body for DeleteProjectFromUser for application/json ContentType.
type DeleteProjectFromUserJSONRequestBody DeleteProjectFromUserJSONBody

// AttachProjectToUserJSONRequestBody defines body for AttachProjectToUser for application/json ContentType.
type AttachProjectToUserJSONRequestBody AttachProjectToUserJSONBody

// PermitProjectUserJSONRequestBody defines body for PermitProjectUser for application/json ContentType.
type PermitProjectUserJSONRequestBody PermitProjectUserJSONBody

// CreateGlobalRunnerJSONRequestBody defines body for CreateGlobalRunner for application/json ContentType.
type CreateGlobalRunnerJSONRequestBody CreateGlobalRunnerJSONBody

// UpdateGlobalRunnerJSONRequestBody defines body for UpdateGlobalRunner for application/json ContentType.
type UpdateGlobalRunnerJSONRequestBody UpdateGlobalRunnerJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// DeleteUserFromGroupJSONRequestBody defines body for DeleteUserFromGroup for application/json ContentType.
type DeleteUserFromGroupJSONRequestBody DeleteUserFromGroupJSONBody

// AttachUserToGroupJSONRequestBody defines body for AttachUserToGroup for application/json ContentType.
type AttachUserToGroupJSONRequestBody AttachUserToGroupJSONBody

// PermitUserGroupJSONRequestBody defines body for PermitUserGroup for application/json ContentType.
type PermitUserGroupJSONRequestBody PermitUserGroupJSONBody

// DeleteUserFromProjectJSONRequestBody defines body for DeleteUserFromProject for application/json ContentType.
type DeleteUserFromProjectJSONRequestBody DeleteUserFromProjectJSONBody

// AttachUserToProjectJSONRequestBody defines body for AttachUserToProject for application/json ContentType.
type AttachUserToProjectJSONRequestBody AttachUserToProjectJSONBody

// PermitUserProjectJSONRequestBody defines body for PermitUserProject for application/json ContentType.
type PermitUserProjectJSONRequestBody PermitUserProjectJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LoginAuthWithBody request with any body
	LoginAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginAuth(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProviders request
	ListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RedirectAuthWithBody request with any body
	RedirectAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RedirectAuth(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshAuth request
	RefreshAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyAuth request
	VerifyAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CallbackProvider request
	CallbackProvider(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestProvider request
	RequestProvider(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGlobalEvents request
	ListGlobalEvents(ctx context.Context, params *ListGlobalEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowGroup request
	ShowGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupWithBody request with any body
	UpdateGroupWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupFromProjectWithBody request with any body
	DeleteGroupFromProjectWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGroupFromProject(ctx context.Context, groupID GroupID, body DeleteGroupFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupProjects request
	ListGroupProjects(ctx context.Context, groupID GroupID, params *ListGroupProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachGroupToProjectWithBody request with any body
	AttachGroupToProjectWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachGroupToProject(ctx context.Context, groupID GroupID, body AttachGroupToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitGroupProjectWithBody request with any body
	PermitGroupProjectWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitGroupProject(ctx context.Context, groupID GroupID, body PermitGroupProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupFromUserWithBody request with any body
	DeleteGroupFromUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGroupFromUser(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupUsers request
	ListGroupUsers(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachGroupToUserWithBody request with any body
	AttachGroupToUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachGroupToUser(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitGroupUserWithBody request with any body
	PermitGroupUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitGroupUser(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProfile request
	ShowProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProfileWithBody request with any body
	UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenProfile request
	TokenProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectWithBody request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProject request
	ShowProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectWithBody request with any body
	UpdateProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectCredentials request
	ListProjectCredentials(ctx context.Context, projectID ProjectID, params *ListProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectCredentialWithBody request with any body
	CreateProjectCredentialWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectCredential(ctx context.Context, projectID ProjectID, body CreateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectCredential request
	DeleteProjectCredential(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectCredential request
	ShowProjectCredential(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectCredentialWithBody request with any body
	UpdateProjectCredentialWithBody(ctx context.Context, projectID ProjectID, credentialID CredentialID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectCredential(ctx context.Context, projectID ProjectID, credentialID CredentialID, body UpdateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectEnvironments request
	ListProjectEnvironments(ctx context.Context, projectID ProjectID, params *ListProjectEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectEnvironmentWithBody request with any body
	CreateProjectEnvironmentWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectEnvironment(ctx context.Context, projectID ProjectID, body CreateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectEnvironment request
	DeleteProjectEnvironment(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectEnvironment request
	ShowProjectEnvironment(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectEnvironmentWithBody request with any body
	UpdateProjectEnvironmentWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectEnvironment(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body UpdateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectEnvironmentSecretWithBody request with any body
	CreateProjectEnvironmentSecretWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectEnvironmentSecret(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectEnvironmentSecret request
	DeleteProjectEnvironmentSecret(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectEnvironmentSecretWithBody request with any body
	UpdateProjectEnvironmentSecretWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectEnvironmentSecret(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, body UpdateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectEnvironmentValueWithBody request with any body
	CreateProjectEnvironmentValueWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectEnvironmentValue(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectEnvironmentValue request
	DeleteProjectEnvironmentValue(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectEnvironmentValueWithBody request with any body
	UpdateProjectEnvironmentValueWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectEnvironmentValue(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, body UpdateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectEvents request
	ListProjectEvents(ctx context.Context, projectID ProjectID, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectExecutions request
	ListProjectExecutions(ctx context.Context, projectID ProjectID, params *ListProjectExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectExecutionWithBody request with any body
	CreateProjectExecutionWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectExecution(ctx context.Context, projectID ProjectID, body CreateProjectExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectExecution request
	DeleteProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectExecution request
	ShowProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OutputProjectExecution request
	OutputProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PurgeProjectExecution request
	PurgeProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectFromGroupWithBody request with any body
	DeleteProjectFromGroupWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteProjectFromGroup(ctx context.Context, projectID ProjectID, body DeleteProjectFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectGroups request
	ListProjectGroups(ctx context.Context, projectID ProjectID, params *ListProjectGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachProjectToGroupWithBody request with any body
	AttachProjectToGroupWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachProjectToGroup(ctx context.Context, projectID ProjectID, body AttachProjectToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitProjectGroupWithBody request with any body
	PermitProjectGroupWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitProjectGroup(ctx context.Context, projectID ProjectID, body PermitProjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectInventories request
	ListProjectInventories(ctx context.Context, projectID ProjectID, params *ListProjectInventoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectInventoryWithBody request with any body
	CreateProjectInventoryWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectInventory(ctx context.Context, projectID ProjectID, body CreateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectInventory request
	DeleteProjectInventory(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectInventory request
	ShowProjectInventory(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectInventoryWithBody request with any body
	UpdateProjectInventoryWithBody(ctx context.Context, projectID ProjectID, inventoryID InventoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectInventory(ctx context.Context, projectID ProjectID, inventoryID InventoryID, body UpdateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectRepositories request
	ListProjectRepositories(ctx context.Context, projectID ProjectID, params *ListProjectRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectRepositoryWithBody request with any body
	CreateProjectRepositoryWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectRepository(ctx context.Context, projectID ProjectID, body CreateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectRepository request
	DeleteProjectRepository(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectRepository request
	ShowProjectRepository(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectRepositoryWithBody request with any body
	UpdateProjectRepositoryWithBody(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectRepository(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, body UpdateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectRunners request
	ListProjectRunners(ctx context.Context, projectID ProjectID, params *ListProjectRunnersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectRunnerWithBody request with any body
	CreateProjectRunnerWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectRunner(ctx context.Context, projectID ProjectID, body CreateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectRunner request
	DeleteProjectRunner(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectRunner request
	ShowProjectRunner(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectRunnerWithBody request with any body
	UpdateProjectRunnerWithBody(ctx context.Context, projectID ProjectID, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectRunner(ctx context.Context, projectID ProjectID, runnerID RunnerID, body UpdateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectSchedules request
	ListProjectSchedules(ctx context.Context, projectID ProjectID, params *ListProjectSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectScheduleWithBody request with any body
	CreateProjectScheduleWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectSchedule(ctx context.Context, projectID ProjectID, body CreateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectSchedule request
	DeleteProjectSchedule(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectSchedule request
	ShowProjectSchedule(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectScheduleWithBody request with any body
	UpdateProjectScheduleWithBody(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectSchedule(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, body UpdateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectTemplates request
	ListProjectTemplates(ctx context.Context, projectID ProjectID, params *ListProjectTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectTemplateWithBody request with any body
	CreateProjectTemplateWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectTemplate(ctx context.Context, projectID ProjectID, body CreateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectTemplate request
	DeleteProjectTemplate(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProjectTemplate request
	ShowProjectTemplate(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectTemplateWithBody request with any body
	UpdateProjectTemplateWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectTemplate(ctx context.Context, projectID ProjectID, templateID TemplateID, body UpdateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectTemplateSurveyWithBody request with any body
	CreateProjectTemplateSurveyWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectTemplateSurvey(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectTemplateSurvey request
	DeleteProjectTemplateSurvey(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectTemplateSurveyWithBody request with any body
	UpdateProjectTemplateSurveyWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectTemplateSurvey(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, body UpdateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectTemplateVaultWithBody request with any body
	CreateProjectTemplateVaultWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectTemplateVault(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectTemplateVault request
	DeleteProjectTemplateVault(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectTemplateVaultWithBody request with any body
	UpdateProjectTemplateVaultWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectTemplateVault(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, body UpdateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectFromUserWithBody request with any body
	DeleteProjectFromUserWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteProjectFromUser(ctx context.Context, projectID ProjectID, body DeleteProjectFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectUsers request
	ListProjectUsers(ctx context.Context, projectID ProjectID, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachProjectToUserWithBody request with any body
	AttachProjectToUserWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachProjectToUser(ctx context.Context, projectID ProjectID, body AttachProjectToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitProjectUserWithBody request with any body
	PermitProjectUserWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitProjectUser(ctx context.Context, projectID ProjectID, body PermitProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGlobalRunners request
	ListGlobalRunners(ctx context.Context, params *ListGlobalRunnersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGlobalRunnerWithBody request with any body
	CreateGlobalRunnerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGlobalRunner(ctx context.Context, body CreateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGlobalRunner request
	DeleteGlobalRunner(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowGlobalRunner request
	ShowGlobalRunner(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGlobalRunnerWithBody request with any body
	UpdateGlobalRunnerWithBody(ctx context.Context, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGlobalRunner(ctx context.Context, runnerID RunnerID, body UpdateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowUser request
	ShowUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromGroupWithBody request with any body
	DeleteUserFromGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromGroup(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserGroups request
	ListUserGroups(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToGroupWithBody request with any body
	AttachUserToGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToGroup(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserGroupWithBody request with any body
	PermitUserGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserGroup(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromProjectWithBody request with any body
	DeleteUserFromProjectWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromProject(ctx context.Context, userID UserID, body DeleteUserFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserProjects request
	ListUserProjects(ctx context.Context, userID UserID, params *ListUserProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToProjectWithBody request with any body
	AttachUserToProjectWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToProject(ctx context.Context, userID UserID, body AttachUserToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserProjectWithBody request with any body
	PermitUserProjectWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserProject(ctx context.Context, userID UserID, body PermitUserProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LoginAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginAuth(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RedirectAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRedirectAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RedirectAuth(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRedirectAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CallbackProvider(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCallbackProviderRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestProvider(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestProviderRequest(c.Server, provider)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGlobalEvents(ctx context.Context, params *ListGlobalEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGlobalEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowGroupRequest(c.Server, groupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromProjectWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromProjectRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromProject(ctx context.Context, groupID GroupID, body DeleteGroupFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromProjectRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupProjects(ctx context.Context, groupID GroupID, params *ListGroupProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupProjectsRequest(c.Server, groupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToProjectWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToProjectRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToProject(ctx context.Context, groupID GroupID, body AttachGroupToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToProjectRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupProjectWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupProjectRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupProject(ctx context.Context, groupID GroupID, body PermitGroupProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupProjectRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromUserRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromUser(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromUserRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupUsers(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupUsersRequest(c.Server, groupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToUserRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToUser(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToUserRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupUserRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupUser(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupUserRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProject(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectRequest(c.Server, projectID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectCredentials(ctx context.Context, projectID ProjectID, params *ListProjectCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectCredentialsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectCredentialWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectCredentialRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectCredential(ctx context.Context, projectID ProjectID, body CreateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectCredentialRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectCredential(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectCredentialRequest(c.Server, projectID, credentialID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectCredential(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectCredentialRequest(c.Server, projectID, credentialID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectCredentialWithBody(ctx context.Context, projectID ProjectID, credentialID CredentialID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectCredentialRequestWithBody(c.Server, projectID, credentialID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectCredential(ctx context.Context, projectID ProjectID, credentialID CredentialID, body UpdateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectCredentialRequest(c.Server, projectID, credentialID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectEnvironments(ctx context.Context, projectID ProjectID, params *ListProjectEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectEnvironmentsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEnvironmentWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEnvironmentRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEnvironment(ctx context.Context, projectID ProjectID, body CreateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEnvironmentRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectEnvironment(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectEnvironmentRequest(c.Server, projectID, environmentID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectEnvironment(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectEnvironmentRequest(c.Server, projectID, environmentID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEnvironmentWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEnvironmentRequestWithBody(c.Server, projectID, environmentID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEnvironment(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body UpdateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEnvironmentRequest(c.Server, projectID, environmentID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEnvironmentSecretWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEnvironmentSecretRequestWithBody(c.Server, projectID, environmentID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEnvironmentSecret(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEnvironmentSecretRequest(c.Server, projectID, environmentID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectEnvironmentSecret(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectEnvironmentSecretRequest(c.Server, projectID, environmentID, secretID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEnvironmentSecretWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEnvironmentSecretRequestWithBody(c.Server, projectID, environmentID, secretID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEnvironmentSecret(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, body UpdateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEnvironmentSecretRequest(c.Server, projectID, environmentID, secretID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEnvironmentValueWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEnvironmentValueRequestWithBody(c.Server, projectID, environmentID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEnvironmentValue(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEnvironmentValueRequest(c.Server, projectID, environmentID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectEnvironmentValue(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectEnvironmentValueRequest(c.Server, projectID, environmentID, valueID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEnvironmentValueWithBody(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEnvironmentValueRequestWithBody(c.Server, projectID, environmentID, valueID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEnvironmentValue(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, body UpdateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEnvironmentValueRequest(c.Server, projectID, environmentID, valueID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectEvents(ctx context.Context, projectID ProjectID, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectEventsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectExecutions(ctx context.Context, projectID ProjectID, params *ListProjectExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectExecutionsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectExecutionWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectExecutionRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectExecution(ctx context.Context, projectID ProjectID, body CreateProjectExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectExecutionRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectExecutionRequest(c.Server, projectID, executionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectExecutionRequest(c.Server, projectID, executionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OutputProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOutputProjectExecutionRequest(c.Server, projectID, executionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PurgeProjectExecution(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPurgeProjectExecutionRequest(c.Server, projectID, executionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectFromGroupWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectFromGroupRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectFromGroup(ctx context.Context, projectID ProjectID, body DeleteProjectFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectFromGroupRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectGroups(ctx context.Context, projectID ProjectID, params *ListProjectGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectGroupsRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachProjectToGroupWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachProjectToGroupRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachProjectToGroup(ctx context.Context, projectID ProjectID, body AttachProjectToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachProjectToGroupRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitProjectGroupWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitProjectGroupRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitProjectGroup(ctx context.Context, projectID ProjectID, body PermitProjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitProjectGroupRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectInventories(ctx context.Context, projectID ProjectID, params *ListProjectInventoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectInventoriesRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectInventoryWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectInventoryRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectInventory(ctx context.Context, projectID ProjectID, body CreateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectInventoryRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectInventory(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectInventoryRequest(c.Server, projectID, inventoryID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectInventory(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectInventoryRequest(c.Server, projectID, inventoryID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectInventoryWithBody(ctx context.Context, projectID ProjectID, inventoryID InventoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectInventoryRequestWithBody(c.Server, projectID, inventoryID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectInventory(ctx context.Context, projectID ProjectID, inventoryID InventoryID, body UpdateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectInventoryRequest(c.Server, projectID, inventoryID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectRepositories(ctx context.Context, projectID ProjectID, params *ListProjectRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectRepositoriesRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectRepositoryWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRepositoryRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectRepository(ctx context.Context, projectID ProjectID, body CreateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRepositoryRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectRepository(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRepositoryRequest(c.Server, projectID, repositoryID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectRepository(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectRepositoryRequest(c.Server, projectID, repositoryID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectRepositoryWithBody(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRepositoryRequestWithBody(c.Server, projectID, repositoryID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectRepository(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, body UpdateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRepositoryRequest(c.Server, projectID, repositoryID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectRunners(ctx context.Context, projectID ProjectID, params *ListProjectRunnersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectRunnersRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectRunnerWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRunnerRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectRunner(ctx context.Context, projectID ProjectID, body CreateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRunnerRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectRunner(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRunnerRequest(c.Server, projectID, runnerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectRunner(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectRunnerRequest(c.Server, projectID, runnerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectRunnerWithBody(ctx context.Context, projectID ProjectID, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRunnerRequestWithBody(c.Server, projectID, runnerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectRunner(ctx context.Context, projectID ProjectID, runnerID RunnerID, body UpdateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRunnerRequest(c.Server, projectID, runnerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectSchedules(ctx context.Context, projectID ProjectID, params *ListProjectSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectSchedulesRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectScheduleWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectScheduleRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectSchedule(ctx context.Context, projectID ProjectID, body CreateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectScheduleRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectSchedule(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectScheduleRequest(c.Server, projectID, scheduleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectSchedule(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectScheduleRequest(c.Server, projectID, scheduleID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectScheduleWithBody(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectScheduleRequestWithBody(c.Server, projectID, scheduleID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectSchedule(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, body UpdateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectScheduleRequest(c.Server, projectID, scheduleID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectTemplates(ctx context.Context, projectID ProjectID, params *ListProjectTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectTemplatesRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectTemplateWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectTemplateRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectTemplate(ctx context.Context, projectID ProjectID, body CreateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectTemplateRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectTemplate(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectTemplateRequest(c.Server, projectID, templateID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProjectTemplate(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProjectTemplateRequest(c.Server, projectID, templateID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectTemplateWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectTemplateRequestWithBody(c.Server, projectID, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectTemplate(ctx context.Context, projectID ProjectID, templateID TemplateID, body UpdateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectTemplateRequest(c.Server, projectID, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectTemplateSurveyWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectTemplateSurveyRequestWithBody(c.Server, projectID, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectTemplateSurvey(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectTemplateSurveyRequest(c.Server, projectID, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectTemplateSurvey(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectTemplateSurveyRequest(c.Server, projectID, templateID, surveyID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectTemplateSurveyWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectTemplateSurveyRequestWithBody(c.Server, projectID, templateID, surveyID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectTemplateSurvey(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, body UpdateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectTemplateSurveyRequest(c.Server, projectID, templateID, surveyID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectTemplateVaultWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectTemplateVaultRequestWithBody(c.Server, projectID, templateID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectTemplateVault(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectTemplateVaultRequest(c.Server, projectID, templateID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectTemplateVault(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectTemplateVaultRequest(c.Server, projectID, templateID, vaultID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectTemplateVaultWithBody(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectTemplateVaultRequestWithBody(c.Server, projectID, templateID, vaultID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectTemplateVault(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, body UpdateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectTemplateVaultRequest(c.Server, projectID, templateID, vaultID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectFromUserWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectFromUserRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectFromUser(ctx context.Context, projectID ProjectID, body DeleteProjectFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectFromUserRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectUsers(ctx context.Context, projectID ProjectID, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectUsersRequest(c.Server, projectID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachProjectToUserWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachProjectToUserRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachProjectToUser(ctx context.Context, projectID ProjectID, body AttachProjectToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachProjectToUserRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitProjectUserWithBody(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitProjectUserRequestWithBody(c.Server, projectID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitProjectUser(ctx context.Context, projectID ProjectID, body PermitProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitProjectUserRequest(c.Server, projectID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGlobalRunners(ctx context.Context, params *ListGlobalRunnersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGlobalRunnersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalRunnerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalRunnerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalRunner(ctx context.Context, body CreateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalRunnerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGlobalRunner(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGlobalRunnerRequest(c.Server, runnerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowGlobalRunner(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowGlobalRunnerRequest(c.Server, runnerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalRunnerWithBody(ctx context.Context, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalRunnerRequestWithBody(c.Server, runnerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalRunner(ctx context.Context, runnerID RunnerID, body UpdateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalRunnerRequest(c.Server, runnerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromGroupRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromGroup(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromGroupRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserGroups(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserGroupsRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToGroupRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToGroup(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToGroupRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserGroupRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserGroup(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserGroupRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromProjectWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromProjectRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromProject(ctx context.Context, userID UserID, body DeleteUserFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromProjectRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserProjects(ctx context.Context, userID UserID, params *ListUserProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserProjectsRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToProjectWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToProjectRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToProject(ctx context.Context, userID UserID, body AttachUserToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToProjectRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserProjectWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserProjectRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserProject(ctx context.Context, userID UserID, body PermitUserProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserProjectRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLoginAuthRequest calls the generic LoginAuth builder with application/json body
func NewLoginAuthRequest(server string, body LoginAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginAuthRequestWithBody generates requests for LoginAuth with any type of body
func NewLoginAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProvidersRequest generates requests for ListProviders
func NewListProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRedirectAuthRequest calls the generic RedirectAuth builder with application/json body
func NewRedirectAuthRequest(server string, body RedirectAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRedirectAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewRedirectAuthRequestWithBody generates requests for RedirectAuth with any type of body
func NewRedirectAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/redirect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshAuthRequest generates requests for RefreshAuth
func NewRefreshAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyAuthRequest generates requests for VerifyAuth
func NewVerifyAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCallbackProviderRequest generates requests for CallbackProvider
func NewCallbackProviderRequest(server string, provider AuthProviderParam, params *CallbackProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/%s/callback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestProviderRequest generates requests for RequestProvider
func NewRequestProviderRequest(server string, provider AuthProviderParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGlobalEventsRequest generates requests for ListGlobalEvents
func NewListGlobalEventsRequest(server string, params *ListGlobalEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupID GroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowGroupRequest generates requests for ShowGroup
func NewShowGroupRequest(server string, groupID GroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, groupID GroupID, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupFromProjectRequest calls the generic DeleteGroupFromProject builder with application/json body
func NewDeleteGroupFromProjectRequest(server string, groupID GroupID, body DeleteGroupFromProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGroupFromProjectRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewDeleteGroupFromProjectRequestWithBody generates requests for DeleteGroupFromProject with any type of body
func NewDeleteGroupFromProjectRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupProjectsRequest generates requests for ListGroupProjects
func NewListGroupProjectsRequest(server string, groupID GroupID, params *ListGroupProjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachGroupToProjectRequest calls the generic AttachGroupToProject builder with application/json body
func NewAttachGroupToProjectRequest(server string, groupID GroupID, body AttachGroupToProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachGroupToProjectRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewAttachGroupToProjectRequestWithBody generates requests for AttachGroupToProject with any type of body
func NewAttachGroupToProjectRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitGroupProjectRequest calls the generic PermitGroupProject builder with application/json body
func NewPermitGroupProjectRequest(server string, groupID GroupID, body PermitGroupProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitGroupProjectRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewPermitGroupProjectRequestWithBody generates requests for PermitGroupProject with any type of body
func NewPermitGroupProjectRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupFromUserRequest calls the generic DeleteGroupFromUser builder with application/json body
func NewDeleteGroupFromUserRequest(server string, groupID GroupID, body DeleteGroupFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGroupFromUserRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewDeleteGroupFromUserRequestWithBody generates requests for DeleteGroupFromUser with any type of body
func NewDeleteGroupFromUserRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupUsersRequest generates requests for ListGroupUsers
func NewListGroupUsersRequest(server string, groupID GroupID, params *ListGroupUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachGroupToUserRequest calls the generic AttachGroupToUser builder with application/json body
func NewAttachGroupToUserRequest(server string, groupID GroupID, body AttachGroupToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachGroupToUserRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewAttachGroupToUserRequestWithBody generates requests for AttachGroupToUser with any type of body
func NewAttachGroupToUserRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitGroupUserRequest calls the generic PermitGroupUser builder with application/json body
func NewPermitGroupUserRequest(server string, groupID GroupID, body PermitGroupUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitGroupUserRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewPermitGroupUserRequestWithBody generates requests for PermitGroupUser with any type of body
func NewPermitGroupUserRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShowProfileRequest generates requests for ShowProfile
func NewShowProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProfileRequest calls the generic UpdateProfile builder with application/json body
func NewUpdateProfileRequest(server string, body UpdateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateProfileRequestWithBody generates requests for UpdateProfile with any type of body
func NewUpdateProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTokenProfileRequest generates requests for TokenProfile
func NewTokenProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectRequest generates requests for ShowProject
func NewShowProjectRequest(server string, projectID ProjectID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, projectID ProjectID, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectCredentialsRequest generates requests for ListProjectCredentials
func NewListProjectCredentialsRequest(server string, projectID ProjectID, params *ListProjectCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectCredentialRequest calls the generic CreateProjectCredential builder with application/json body
func NewCreateProjectCredentialRequest(server string, projectID ProjectID, body CreateProjectCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectCredentialRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectCredentialRequestWithBody generates requests for CreateProjectCredential with any type of body
func NewCreateProjectCredentialRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectCredentialRequest generates requests for DeleteProjectCredential
func NewDeleteProjectCredentialRequest(server string, projectID ProjectID, credentialID CredentialID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credential_id", runtime.ParamLocationPath, credentialID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectCredentialRequest generates requests for ShowProjectCredential
func NewShowProjectCredentialRequest(server string, projectID ProjectID, credentialID CredentialID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credential_id", runtime.ParamLocationPath, credentialID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectCredentialRequest calls the generic UpdateProjectCredential builder with application/json body
func NewUpdateProjectCredentialRequest(server string, projectID ProjectID, credentialID CredentialID, body UpdateProjectCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectCredentialRequestWithBody(server, projectID, credentialID, "application/json", bodyReader)
}

// NewUpdateProjectCredentialRequestWithBody generates requests for UpdateProjectCredential with any type of body
func NewUpdateProjectCredentialRequestWithBody(server string, projectID ProjectID, credentialID CredentialID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credential_id", runtime.ParamLocationPath, credentialID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectEnvironmentsRequest generates requests for ListProjectEnvironments
func NewListProjectEnvironmentsRequest(server string, projectID ProjectID, params *ListProjectEnvironmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectEnvironmentRequest calls the generic CreateProjectEnvironment builder with application/json body
func NewCreateProjectEnvironmentRequest(server string, projectID ProjectID, body CreateProjectEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectEnvironmentRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectEnvironmentRequestWithBody generates requests for CreateProjectEnvironment with any type of body
func NewCreateProjectEnvironmentRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectEnvironmentRequest generates requests for DeleteProjectEnvironment
func NewDeleteProjectEnvironmentRequest(server string, projectID ProjectID, environmentID EnvironmentID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectEnvironmentRequest generates requests for ShowProjectEnvironment
func NewShowProjectEnvironmentRequest(server string, projectID ProjectID, environmentID EnvironmentID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectEnvironmentRequest calls the generic UpdateProjectEnvironment builder with application/json body
func NewUpdateProjectEnvironmentRequest(server string, projectID ProjectID, environmentID EnvironmentID, body UpdateProjectEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectEnvironmentRequestWithBody(server, projectID, environmentID, "application/json", bodyReader)
}

// NewUpdateProjectEnvironmentRequestWithBody generates requests for UpdateProjectEnvironment with any type of body
func NewUpdateProjectEnvironmentRequestWithBody(server string, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateProjectEnvironmentSecretRequest calls the generic CreateProjectEnvironmentSecret builder with application/json body
func NewCreateProjectEnvironmentSecretRequest(server string, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectEnvironmentSecretRequestWithBody(server, projectID, environmentID, "application/json", bodyReader)
}

// NewCreateProjectEnvironmentSecretRequestWithBody generates requests for CreateProjectEnvironmentSecret with any type of body
func NewCreateProjectEnvironmentSecretRequestWithBody(server string, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s/secrets", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectEnvironmentSecretRequest generates requests for DeleteProjectEnvironmentSecret
func NewDeleteProjectEnvironmentSecretRequest(server string, projectID ProjectID, environmentID EnvironmentID, secretID SecretID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_id", runtime.ParamLocationPath, secretID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectEnvironmentSecretRequest calls the generic UpdateProjectEnvironmentSecret builder with application/json body
func NewUpdateProjectEnvironmentSecretRequest(server string, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, body UpdateProjectEnvironmentSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectEnvironmentSecretRequestWithBody(server, projectID, environmentID, secretID, "application/json", bodyReader)
}

// NewUpdateProjectEnvironmentSecretRequestWithBody generates requests for UpdateProjectEnvironmentSecret with any type of body
func NewUpdateProjectEnvironmentSecretRequestWithBody(server string, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_id", runtime.ParamLocationPath, secretID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateProjectEnvironmentValueRequest calls the generic CreateProjectEnvironmentValue builder with application/json body
func NewCreateProjectEnvironmentValueRequest(server string, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectEnvironmentValueRequestWithBody(server, projectID, environmentID, "application/json", bodyReader)
}

// NewCreateProjectEnvironmentValueRequestWithBody generates requests for CreateProjectEnvironmentValue with any type of body
func NewCreateProjectEnvironmentValueRequestWithBody(server string, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectEnvironmentValueRequest generates requests for DeleteProjectEnvironmentValue
func NewDeleteProjectEnvironmentValueRequest(server string, projectID ProjectID, environmentID EnvironmentID, valueID ValueID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "value_id", runtime.ParamLocationPath, valueID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s/values/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectEnvironmentValueRequest calls the generic UpdateProjectEnvironmentValue builder with application/json body
func NewUpdateProjectEnvironmentValueRequest(server string, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, body UpdateProjectEnvironmentValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectEnvironmentValueRequestWithBody(server, projectID, environmentID, valueID, "application/json", bodyReader)
}

// NewUpdateProjectEnvironmentValueRequestWithBody generates requests for UpdateProjectEnvironmentValue with any type of body
func NewUpdateProjectEnvironmentValueRequestWithBody(server string, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_id", runtime.ParamLocationPath, environmentID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "value_id", runtime.ParamLocationPath, valueID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/environments/%s/values/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectEventsRequest generates requests for ListProjectEvents
func NewListProjectEventsRequest(server string, projectID ProjectID, params *ListProjectEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectExecutionsRequest generates requests for ListProjectExecutions
func NewListProjectExecutionsRequest(server string, projectID ProjectID, params *ListProjectExecutionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectExecutionRequest calls the generic CreateProjectExecution builder with application/json body
func NewCreateProjectExecutionRequest(server string, projectID ProjectID, body CreateProjectExecutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectExecutionRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectExecutionRequestWithBody generates requests for CreateProjectExecution with any type of body
func NewCreateProjectExecutionRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectExecutionRequest generates requests for DeleteProjectExecution
func NewDeleteProjectExecutionRequest(server string, projectID ProjectID, executionID ExecutionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "execution_id", runtime.ParamLocationPath, executionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectExecutionRequest generates requests for ShowProjectExecution
func NewShowProjectExecutionRequest(server string, projectID ProjectID, executionID ExecutionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "execution_id", runtime.ParamLocationPath, executionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOutputProjectExecutionRequest generates requests for OutputProjectExecution
func NewOutputProjectExecutionRequest(server string, projectID ProjectID, executionID ExecutionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "execution_id", runtime.ParamLocationPath, executionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/executions/%s/output", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPurgeProjectExecutionRequest generates requests for PurgeProjectExecution
func NewPurgeProjectExecutionRequest(server string, projectID ProjectID, executionID ExecutionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "execution_id", runtime.ParamLocationPath, executionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/executions/%s/purge", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProjectFromGroupRequest calls the generic DeleteProjectFromGroup builder with application/json body
func NewDeleteProjectFromGroupRequest(server string, projectID ProjectID, body DeleteProjectFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteProjectFromGroupRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewDeleteProjectFromGroupRequestWithBody generates requests for DeleteProjectFromGroup with any type of body
func NewDeleteProjectFromGroupRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectGroupsRequest generates requests for ListProjectGroups
func NewListProjectGroupsRequest(server string, projectID ProjectID, params *ListProjectGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachProjectToGroupRequest calls the generic AttachProjectToGroup builder with application/json body
func NewAttachProjectToGroupRequest(server string, projectID ProjectID, body AttachProjectToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachProjectToGroupRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewAttachProjectToGroupRequestWithBody generates requests for AttachProjectToGroup with any type of body
func NewAttachProjectToGroupRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitProjectGroupRequest calls the generic PermitProjectGroup builder with application/json body
func NewPermitProjectGroupRequest(server string, projectID ProjectID, body PermitProjectGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitProjectGroupRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewPermitProjectGroupRequestWithBody generates requests for PermitProjectGroup with any type of body
func NewPermitProjectGroupRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectInventoriesRequest generates requests for ListProjectInventories
func NewListProjectInventoriesRequest(server string, projectID ProjectID, params *ListProjectInventoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/inventories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectInventoryRequest calls the generic CreateProjectInventory builder with application/json body
func NewCreateProjectInventoryRequest(server string, projectID ProjectID, body CreateProjectInventoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectInventoryRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectInventoryRequestWithBody generates requests for CreateProjectInventory with any type of body
func NewCreateProjectInventoryRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/inventories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectInventoryRequest generates requests for DeleteProjectInventory
func NewDeleteProjectInventoryRequest(server string, projectID ProjectID, inventoryID InventoryID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "inventory_id", runtime.ParamLocationPath, inventoryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/inventories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectInventoryRequest generates requests for ShowProjectInventory
func NewShowProjectInventoryRequest(server string, projectID ProjectID, inventoryID InventoryID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "inventory_id", runtime.ParamLocationPath, inventoryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/inventories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectInventoryRequest calls the generic UpdateProjectInventory builder with application/json body
func NewUpdateProjectInventoryRequest(server string, projectID ProjectID, inventoryID InventoryID, body UpdateProjectInventoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectInventoryRequestWithBody(server, projectID, inventoryID, "application/json", bodyReader)
}

// NewUpdateProjectInventoryRequestWithBody generates requests for UpdateProjectInventory with any type of body
func NewUpdateProjectInventoryRequestWithBody(server string, projectID ProjectID, inventoryID InventoryID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "inventory_id", runtime.ParamLocationPath, inventoryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/inventories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectRepositoriesRequest generates requests for ListProjectRepositories
func NewListProjectRepositoriesRequest(server string, projectID ProjectID, params *ListProjectRepositoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRepositoryRequest calls the generic CreateProjectRepository builder with application/json body
func NewCreateProjectRepositoryRequest(server string, projectID ProjectID, body CreateProjectRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRepositoryRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectRepositoryRequestWithBody generates requests for CreateProjectRepository with any type of body
func NewCreateProjectRepositoryRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRepositoryRequest generates requests for DeleteProjectRepository
func NewDeleteProjectRepositoryRequest(server string, projectID ProjectID, repositoryID RepositoryID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectRepositoryRequest generates requests for ShowProjectRepository
func NewShowProjectRepositoryRequest(server string, projectID ProjectID, repositoryID RepositoryID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRepositoryRequest calls the generic UpdateProjectRepository builder with application/json body
func NewUpdateProjectRepositoryRequest(server string, projectID ProjectID, repositoryID RepositoryID, body UpdateProjectRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRepositoryRequestWithBody(server, projectID, repositoryID, "application/json", bodyReader)
}

// NewUpdateProjectRepositoryRequestWithBody generates requests for UpdateProjectRepository with any type of body
func NewUpdateProjectRepositoryRequestWithBody(server string, projectID ProjectID, repositoryID RepositoryID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectRunnersRequest generates requests for ListProjectRunners
func NewListProjectRunnersRequest(server string, projectID ProjectID, params *ListProjectRunnersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/runners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRunnerRequest calls the generic CreateProjectRunner builder with application/json body
func NewCreateProjectRunnerRequest(server string, projectID ProjectID, body CreateProjectRunnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRunnerRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectRunnerRequestWithBody generates requests for CreateProjectRunner with any type of body
func NewCreateProjectRunnerRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/runners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRunnerRequest generates requests for DeleteProjectRunner
func NewDeleteProjectRunnerRequest(server string, projectID ProjectID, runnerID RunnerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/runners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectRunnerRequest generates requests for ShowProjectRunner
func NewShowProjectRunnerRequest(server string, projectID ProjectID, runnerID RunnerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/runners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRunnerRequest calls the generic UpdateProjectRunner builder with application/json body
func NewUpdateProjectRunnerRequest(server string, projectID ProjectID, runnerID RunnerID, body UpdateProjectRunnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRunnerRequestWithBody(server, projectID, runnerID, "application/json", bodyReader)
}

// NewUpdateProjectRunnerRequestWithBody generates requests for UpdateProjectRunner with any type of body
func NewUpdateProjectRunnerRequestWithBody(server string, projectID ProjectID, runnerID RunnerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/runners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectSchedulesRequest generates requests for ListProjectSchedules
func NewListProjectSchedulesRequest(server string, projectID ProjectID, params *ListProjectSchedulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/schedules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectScheduleRequest calls the generic CreateProjectSchedule builder with application/json body
func NewCreateProjectScheduleRequest(server string, projectID ProjectID, body CreateProjectScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectScheduleRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectScheduleRequestWithBody generates requests for CreateProjectSchedule with any type of body
func NewCreateProjectScheduleRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/schedules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectScheduleRequest generates requests for DeleteProjectSchedule
func NewDeleteProjectScheduleRequest(server string, projectID ProjectID, scheduleID ScheduleID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schedule_id", runtime.ParamLocationPath, scheduleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/schedules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectScheduleRequest generates requests for ShowProjectSchedule
func NewShowProjectScheduleRequest(server string, projectID ProjectID, scheduleID ScheduleID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schedule_id", runtime.ParamLocationPath, scheduleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/schedules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectScheduleRequest calls the generic UpdateProjectSchedule builder with application/json body
func NewUpdateProjectScheduleRequest(server string, projectID ProjectID, scheduleID ScheduleID, body UpdateProjectScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectScheduleRequestWithBody(server, projectID, scheduleID, "application/json", bodyReader)
}

// NewUpdateProjectScheduleRequestWithBody generates requests for UpdateProjectSchedule with any type of body
func NewUpdateProjectScheduleRequestWithBody(server string, projectID ProjectID, scheduleID ScheduleID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schedule_id", runtime.ParamLocationPath, scheduleID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/schedules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectTemplatesRequest generates requests for ListProjectTemplates
func NewListProjectTemplatesRequest(server string, projectID ProjectID, params *ListProjectTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectTemplateRequest calls the generic CreateProjectTemplate builder with application/json body
func NewCreateProjectTemplateRequest(server string, projectID ProjectID, body CreateProjectTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectTemplateRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewCreateProjectTemplateRequestWithBody generates requests for CreateProjectTemplate with any type of body
func NewCreateProjectTemplateRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectTemplateRequest generates requests for DeleteProjectTemplate
func NewDeleteProjectTemplateRequest(server string, projectID ProjectID, templateID TemplateID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowProjectTemplateRequest generates requests for ShowProjectTemplate
func NewShowProjectTemplateRequest(server string, projectID ProjectID, templateID TemplateID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectTemplateRequest calls the generic UpdateProjectTemplate builder with application/json body
func NewUpdateProjectTemplateRequest(server string, projectID ProjectID, templateID TemplateID, body UpdateProjectTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectTemplateRequestWithBody(server, projectID, templateID, "application/json", bodyReader)
}

// NewUpdateProjectTemplateRequestWithBody generates requests for UpdateProjectTemplate with any type of body
func NewUpdateProjectTemplateRequestWithBody(server string, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateProjectTemplateSurveyRequest calls the generic CreateProjectTemplateSurvey builder with application/json body
func NewCreateProjectTemplateSurveyRequest(server string, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateSurveyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectTemplateSurveyRequestWithBody(server, projectID, templateID, "application/json", bodyReader)
}

// NewCreateProjectTemplateSurveyRequestWithBody generates requests for CreateProjectTemplateSurvey with any type of body
func NewCreateProjectTemplateSurveyRequestWithBody(server string, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s/surveys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectTemplateSurveyRequest generates requests for DeleteProjectTemplateSurvey
func NewDeleteProjectTemplateSurveyRequest(server string, projectID ProjectID, templateID TemplateID, surveyID SurveyID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "survey_id", runtime.ParamLocationPath, surveyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s/surveys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectTemplateSurveyRequest calls the generic UpdateProjectTemplateSurvey builder with application/json body
func NewUpdateProjectTemplateSurveyRequest(server string, projectID ProjectID, templateID TemplateID, surveyID SurveyID, body UpdateProjectTemplateSurveyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectTemplateSurveyRequestWithBody(server, projectID, templateID, surveyID, "application/json", bodyReader)
}

// NewUpdateProjectTemplateSurveyRequestWithBody generates requests for UpdateProjectTemplateSurvey with any type of body
func NewUpdateProjectTemplateSurveyRequestWithBody(server string, projectID ProjectID, templateID TemplateID, surveyID SurveyID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "survey_id", runtime.ParamLocationPath, surveyID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s/surveys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateProjectTemplateVaultRequest calls the generic CreateProjectTemplateVault builder with application/json body
func NewCreateProjectTemplateVaultRequest(server string, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateVaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectTemplateVaultRequestWithBody(server, projectID, templateID, "application/json", bodyReader)
}

// NewCreateProjectTemplateVaultRequestWithBody generates requests for CreateProjectTemplateVault with any type of body
func NewCreateProjectTemplateVaultRequestWithBody(server string, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s/vaults", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectTemplateVaultRequest generates requests for DeleteProjectTemplateVault
func NewDeleteProjectTemplateVaultRequest(server string, projectID ProjectID, templateID TemplateID, vaultID VaultID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s/vaults/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectTemplateVaultRequest calls the generic UpdateProjectTemplateVault builder with application/json body
func NewUpdateProjectTemplateVaultRequest(server string, projectID ProjectID, templateID TemplateID, vaultID VaultID, body UpdateProjectTemplateVaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectTemplateVaultRequestWithBody(server, projectID, templateID, vaultID, "application/json", bodyReader)
}

// NewUpdateProjectTemplateVaultRequestWithBody generates requests for UpdateProjectTemplateVault with any type of body
func NewUpdateProjectTemplateVaultRequestWithBody(server string, projectID ProjectID, templateID TemplateID, vaultID VaultID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_id", runtime.ParamLocationPath, templateID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "vault_id", runtime.ParamLocationPath, vaultID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/templates/%s/vaults/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectFromUserRequest calls the generic DeleteProjectFromUser builder with application/json body
func NewDeleteProjectFromUserRequest(server string, projectID ProjectID, body DeleteProjectFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteProjectFromUserRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewDeleteProjectFromUserRequestWithBody generates requests for DeleteProjectFromUser with any type of body
func NewDeleteProjectFromUserRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectUsersRequest generates requests for ListProjectUsers
func NewListProjectUsersRequest(server string, projectID ProjectID, params *ListProjectUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachProjectToUserRequest calls the generic AttachProjectToUser builder with application/json body
func NewAttachProjectToUserRequest(server string, projectID ProjectID, body AttachProjectToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachProjectToUserRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewAttachProjectToUserRequestWithBody generates requests for AttachProjectToUser with any type of body
func NewAttachProjectToUserRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitProjectUserRequest calls the generic PermitProjectUser builder with application/json body
func NewPermitProjectUserRequest(server string, projectID ProjectID, body PermitProjectUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitProjectUserRequestWithBody(server, projectID, "application/json", bodyReader)
}

// NewPermitProjectUserRequestWithBody generates requests for PermitProjectUser with any type of body
func NewPermitProjectUserRequestWithBody(server string, projectID ProjectID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGlobalRunnersRequest generates requests for ListGlobalRunners
func NewListGlobalRunnersRequest(server string, params *ListGlobalRunnersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/runners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGlobalRunnerRequest calls the generic CreateGlobalRunner builder with application/json body
func NewCreateGlobalRunnerRequest(server string, body CreateGlobalRunnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGlobalRunnerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGlobalRunnerRequestWithBody generates requests for CreateGlobalRunner with any type of body
func NewCreateGlobalRunnerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/runners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGlobalRunnerRequest generates requests for DeleteGlobalRunner
func NewDeleteGlobalRunnerRequest(server string, runnerID RunnerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/runners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowGlobalRunnerRequest generates requests for ShowGlobalRunner
func NewShowGlobalRunnerRequest(server string, runnerID RunnerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/runners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGlobalRunnerRequest calls the generic UpdateGlobalRunner builder with application/json body
func NewUpdateGlobalRunnerRequest(server string, runnerID RunnerID, body UpdateGlobalRunnerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGlobalRunnerRequestWithBody(server, runnerID, "application/json", bodyReader)
}

// NewUpdateGlobalRunnerRequestWithBody generates requests for UpdateGlobalRunner with any type of body
func NewUpdateGlobalRunnerRequestWithBody(server string, runnerID RunnerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/runners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowUserRequest generates requests for ShowUser
func NewShowUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userID UserID, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromGroupRequest calls the generic DeleteUserFromGroup builder with application/json body
func NewDeleteUserFromGroupRequest(server string, userID UserID, body DeleteUserFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromGroupRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewDeleteUserFromGroupRequestWithBody generates requests for DeleteUserFromGroup with any type of body
func NewDeleteUserFromGroupRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserGroupsRequest generates requests for ListUserGroups
func NewListUserGroupsRequest(server string, userID UserID, params *ListUserGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToGroupRequest calls the generic AttachUserToGroup builder with application/json body
func NewAttachUserToGroupRequest(server string, userID UserID, body AttachUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToGroupRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewAttachUserToGroupRequestWithBody generates requests for AttachUserToGroup with any type of body
func NewAttachUserToGroupRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserGroupRequest calls the generic PermitUserGroup builder with application/json body
func NewPermitUserGroupRequest(server string, userID UserID, body PermitUserGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserGroupRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPermitUserGroupRequestWithBody generates requests for PermitUserGroup with any type of body
func NewPermitUserGroupRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromProjectRequest calls the generic DeleteUserFromProject builder with application/json body
func NewDeleteUserFromProjectRequest(server string, userID UserID, body DeleteUserFromProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromProjectRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewDeleteUserFromProjectRequestWithBody generates requests for DeleteUserFromProject with any type of body
func NewDeleteUserFromProjectRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserProjectsRequest generates requests for ListUserProjects
func NewListUserProjectsRequest(server string, userID UserID, params *ListUserProjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToProjectRequest calls the generic AttachUserToProject builder with application/json body
func NewAttachUserToProjectRequest(server string, userID UserID, body AttachUserToProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToProjectRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewAttachUserToProjectRequestWithBody generates requests for AttachUserToProject with any type of body
func NewAttachUserToProjectRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserProjectRequest calls the generic PermitUserProject builder with application/json body
func NewPermitUserProjectRequest(server string, userID UserID, body PermitUserProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserProjectRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPermitUserProjectRequestWithBody generates requests for PermitUserProject with any type of body
func NewPermitUserProjectRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LoginAuthWithBodyWithResponse request with any body
	LoginAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error)

	LoginAuthWithResponse(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error)

	// ListProvidersWithResponse request
	ListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error)

	// RedirectAuthWithBodyWithResponse request with any body
	RedirectAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error)

	RedirectAuthWithResponse(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error)

	// RefreshAuthWithResponse request
	RefreshAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshAuthResponse, error)

	// VerifyAuthWithResponse request
	VerifyAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VerifyAuthResponse, error)

	// CallbackProviderWithResponse request
	CallbackProviderWithResponse(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*CallbackProviderResponse, error)

	// RequestProviderWithResponse request
	RequestProviderWithResponse(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*RequestProviderResponse, error)

	// ListGlobalEventsWithResponse request
	ListGlobalEventsWithResponse(ctx context.Context, params *ListGlobalEventsParams, reqEditors ...RequestEditorFn) (*ListGlobalEventsResponse, error)

	// ListGroupsWithResponse request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// ShowGroupWithResponse request
	ShowGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*ShowGroupResponse, error)

	// UpdateGroupWithBodyWithResponse request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// DeleteGroupFromProjectWithBodyWithResponse request with any body
	DeleteGroupFromProjectWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromProjectResponse, error)

	DeleteGroupFromProjectWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromProjectResponse, error)

	// ListGroupProjectsWithResponse request
	ListGroupProjectsWithResponse(ctx context.Context, groupID GroupID, params *ListGroupProjectsParams, reqEditors ...RequestEditorFn) (*ListGroupProjectsResponse, error)

	// AttachGroupToProjectWithBodyWithResponse request with any body
	AttachGroupToProjectWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToProjectResponse, error)

	AttachGroupToProjectWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToProjectResponse, error)

	// PermitGroupProjectWithBodyWithResponse request with any body
	PermitGroupProjectWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupProjectResponse, error)

	PermitGroupProjectWithResponse(ctx context.Context, groupID GroupID, body PermitGroupProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupProjectResponse, error)

	// DeleteGroupFromUserWithBodyWithResponse request with any body
	DeleteGroupFromUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error)

	DeleteGroupFromUserWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error)

	// ListGroupUsersWithResponse request
	ListGroupUsersWithResponse(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*ListGroupUsersResponse, error)

	// AttachGroupToUserWithBodyWithResponse request with any body
	AttachGroupToUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error)

	AttachGroupToUserWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error)

	// PermitGroupUserWithBodyWithResponse request with any body
	PermitGroupUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error)

	PermitGroupUserWithResponse(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error)

	// ShowProfileWithResponse request
	ShowProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShowProfileResponse, error)

	// UpdateProfileWithBodyWithResponse request with any body
	UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	// TokenProfileWithResponse request
	TokenProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokenProfileResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateProjectWithBodyWithResponse request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// DeleteProjectWithResponse request
	DeleteProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// ShowProjectWithResponse request
	ShowProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ShowProjectResponse, error)

	// UpdateProjectWithBodyWithResponse request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// ListProjectCredentialsWithResponse request
	ListProjectCredentialsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ListProjectCredentialsResponse, error)

	// CreateProjectCredentialWithBodyWithResponse request with any body
	CreateProjectCredentialWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectCredentialResponse, error)

	CreateProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectCredentialResponse, error)

	// DeleteProjectCredentialWithResponse request
	DeleteProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*DeleteProjectCredentialResponse, error)

	// ShowProjectCredentialWithResponse request
	ShowProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*ShowProjectCredentialResponse, error)

	// UpdateProjectCredentialWithBodyWithResponse request with any body
	UpdateProjectCredentialWithBodyWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectCredentialResponse, error)

	UpdateProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, body UpdateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectCredentialResponse, error)

	// ListProjectEnvironmentsWithResponse request
	ListProjectEnvironmentsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectEnvironmentsParams, reqEditors ...RequestEditorFn) (*ListProjectEnvironmentsResponse, error)

	// CreateProjectEnvironmentWithBodyWithResponse request with any body
	CreateProjectEnvironmentWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentResponse, error)

	CreateProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentResponse, error)

	// DeleteProjectEnvironmentWithResponse request
	DeleteProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*DeleteProjectEnvironmentResponse, error)

	// ShowProjectEnvironmentWithResponse request
	ShowProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*ShowProjectEnvironmentResponse, error)

	// UpdateProjectEnvironmentWithBodyWithResponse request with any body
	UpdateProjectEnvironmentWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentResponse, error)

	UpdateProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body UpdateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentResponse, error)

	// CreateProjectEnvironmentSecretWithBodyWithResponse request with any body
	CreateProjectEnvironmentSecretWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentSecretResponse, error)

	CreateProjectEnvironmentSecretWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentSecretResponse, error)

	// DeleteProjectEnvironmentSecretWithResponse request
	DeleteProjectEnvironmentSecretWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, reqEditors ...RequestEditorFn) (*DeleteProjectEnvironmentSecretResponse, error)

	// UpdateProjectEnvironmentSecretWithBodyWithResponse request with any body
	UpdateProjectEnvironmentSecretWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentSecretResponse, error)

	UpdateProjectEnvironmentSecretWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, body UpdateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentSecretResponse, error)

	// CreateProjectEnvironmentValueWithBodyWithResponse request with any body
	CreateProjectEnvironmentValueWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentValueResponse, error)

	CreateProjectEnvironmentValueWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentValueResponse, error)

	// DeleteProjectEnvironmentValueWithResponse request
	DeleteProjectEnvironmentValueWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, reqEditors ...RequestEditorFn) (*DeleteProjectEnvironmentValueResponse, error)

	// UpdateProjectEnvironmentValueWithBodyWithResponse request with any body
	UpdateProjectEnvironmentValueWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentValueResponse, error)

	UpdateProjectEnvironmentValueWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, body UpdateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentValueResponse, error)

	// ListProjectEventsWithResponse request
	ListProjectEventsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*ListProjectEventsResponse, error)

	// ListProjectExecutionsWithResponse request
	ListProjectExecutionsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectExecutionsParams, reqEditors ...RequestEditorFn) (*ListProjectExecutionsResponse, error)

	// CreateProjectExecutionWithBodyWithResponse request with any body
	CreateProjectExecutionWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectExecutionResponse, error)

	CreateProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectExecutionResponse, error)

	// DeleteProjectExecutionWithResponse request
	DeleteProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*DeleteProjectExecutionResponse, error)

	// ShowProjectExecutionWithResponse request
	ShowProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*ShowProjectExecutionResponse, error)

	// OutputProjectExecutionWithResponse request
	OutputProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*OutputProjectExecutionResponse, error)

	// PurgeProjectExecutionWithResponse request
	PurgeProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*PurgeProjectExecutionResponse, error)

	// DeleteProjectFromGroupWithBodyWithResponse request with any body
	DeleteProjectFromGroupWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProjectFromGroupResponse, error)

	DeleteProjectFromGroupWithResponse(ctx context.Context, projectID ProjectID, body DeleteProjectFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProjectFromGroupResponse, error)

	// ListProjectGroupsWithResponse request
	ListProjectGroupsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectGroupsParams, reqEditors ...RequestEditorFn) (*ListProjectGroupsResponse, error)

	// AttachProjectToGroupWithBodyWithResponse request with any body
	AttachProjectToGroupWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachProjectToGroupResponse, error)

	AttachProjectToGroupWithResponse(ctx context.Context, projectID ProjectID, body AttachProjectToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachProjectToGroupResponse, error)

	// PermitProjectGroupWithBodyWithResponse request with any body
	PermitProjectGroupWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitProjectGroupResponse, error)

	PermitProjectGroupWithResponse(ctx context.Context, projectID ProjectID, body PermitProjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitProjectGroupResponse, error)

	// ListProjectInventoriesWithResponse request
	ListProjectInventoriesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectInventoriesParams, reqEditors ...RequestEditorFn) (*ListProjectInventoriesResponse, error)

	// CreateProjectInventoryWithBodyWithResponse request with any body
	CreateProjectInventoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectInventoryResponse, error)

	CreateProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectInventoryResponse, error)

	// DeleteProjectInventoryWithResponse request
	DeleteProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*DeleteProjectInventoryResponse, error)

	// ShowProjectInventoryWithResponse request
	ShowProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*ShowProjectInventoryResponse, error)

	// UpdateProjectInventoryWithBodyWithResponse request with any body
	UpdateProjectInventoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectInventoryResponse, error)

	UpdateProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, body UpdateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectInventoryResponse, error)

	// ListProjectRepositoriesWithResponse request
	ListProjectRepositoriesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectRepositoriesParams, reqEditors ...RequestEditorFn) (*ListProjectRepositoriesResponse, error)

	// CreateProjectRepositoryWithBodyWithResponse request with any body
	CreateProjectRepositoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectRepositoryResponse, error)

	CreateProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectRepositoryResponse, error)

	// DeleteProjectRepositoryWithResponse request
	DeleteProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*DeleteProjectRepositoryResponse, error)

	// ShowProjectRepositoryWithResponse request
	ShowProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*ShowProjectRepositoryResponse, error)

	// UpdateProjectRepositoryWithBodyWithResponse request with any body
	UpdateProjectRepositoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectRepositoryResponse, error)

	UpdateProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, body UpdateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectRepositoryResponse, error)

	// ListProjectRunnersWithResponse request
	ListProjectRunnersWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectRunnersParams, reqEditors ...RequestEditorFn) (*ListProjectRunnersResponse, error)

	// CreateProjectRunnerWithBodyWithResponse request with any body
	CreateProjectRunnerWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectRunnerResponse, error)

	CreateProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectRunnerResponse, error)

	// DeleteProjectRunnerWithResponse request
	DeleteProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*DeleteProjectRunnerResponse, error)

	// ShowProjectRunnerWithResponse request
	ShowProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*ShowProjectRunnerResponse, error)

	// UpdateProjectRunnerWithBodyWithResponse request with any body
	UpdateProjectRunnerWithBodyWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectRunnerResponse, error)

	UpdateProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, body UpdateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectRunnerResponse, error)

	// ListProjectSchedulesWithResponse request
	ListProjectSchedulesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectSchedulesParams, reqEditors ...RequestEditorFn) (*ListProjectSchedulesResponse, error)

	// CreateProjectScheduleWithBodyWithResponse request with any body
	CreateProjectScheduleWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectScheduleResponse, error)

	CreateProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectScheduleResponse, error)

	// DeleteProjectScheduleWithResponse request
	DeleteProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*DeleteProjectScheduleResponse, error)

	// ShowProjectScheduleWithResponse request
	ShowProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*ShowProjectScheduleResponse, error)

	// UpdateProjectScheduleWithBodyWithResponse request with any body
	UpdateProjectScheduleWithBodyWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectScheduleResponse, error)

	UpdateProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, body UpdateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectScheduleResponse, error)

	// ListProjectTemplatesWithResponse request
	ListProjectTemplatesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectTemplatesParams, reqEditors ...RequestEditorFn) (*ListProjectTemplatesResponse, error)

	// CreateProjectTemplateWithBodyWithResponse request with any body
	CreateProjectTemplateWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectTemplateResponse, error)

	CreateProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectTemplateResponse, error)

	// DeleteProjectTemplateWithResponse request
	DeleteProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteProjectTemplateResponse, error)

	// ShowProjectTemplateWithResponse request
	ShowProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*ShowProjectTemplateResponse, error)

	// UpdateProjectTemplateWithBodyWithResponse request with any body
	UpdateProjectTemplateWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateResponse, error)

	UpdateProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, body UpdateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateResponse, error)

	// CreateProjectTemplateSurveyWithBodyWithResponse request with any body
	CreateProjectTemplateSurveyWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectTemplateSurveyResponse, error)

	CreateProjectTemplateSurveyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectTemplateSurveyResponse, error)

	// DeleteProjectTemplateSurveyWithResponse request
	DeleteProjectTemplateSurveyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, reqEditors ...RequestEditorFn) (*DeleteProjectTemplateSurveyResponse, error)

	// UpdateProjectTemplateSurveyWithBodyWithResponse request with any body
	UpdateProjectTemplateSurveyWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateSurveyResponse, error)

	UpdateProjectTemplateSurveyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, body UpdateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateSurveyResponse, error)

	// CreateProjectTemplateVaultWithBodyWithResponse request with any body
	CreateProjectTemplateVaultWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectTemplateVaultResponse, error)

	CreateProjectTemplateVaultWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectTemplateVaultResponse, error)

	// DeleteProjectTemplateVaultWithResponse request
	DeleteProjectTemplateVaultWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, reqEditors ...RequestEditorFn) (*DeleteProjectTemplateVaultResponse, error)

	// UpdateProjectTemplateVaultWithBodyWithResponse request with any body
	UpdateProjectTemplateVaultWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateVaultResponse, error)

	UpdateProjectTemplateVaultWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, body UpdateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateVaultResponse, error)

	// DeleteProjectFromUserWithBodyWithResponse request with any body
	DeleteProjectFromUserWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProjectFromUserResponse, error)

	DeleteProjectFromUserWithResponse(ctx context.Context, projectID ProjectID, body DeleteProjectFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProjectFromUserResponse, error)

	// ListProjectUsersWithResponse request
	ListProjectUsersWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*ListProjectUsersResponse, error)

	// AttachProjectToUserWithBodyWithResponse request with any body
	AttachProjectToUserWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachProjectToUserResponse, error)

	AttachProjectToUserWithResponse(ctx context.Context, projectID ProjectID, body AttachProjectToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachProjectToUserResponse, error)

	// PermitProjectUserWithBodyWithResponse request with any body
	PermitProjectUserWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitProjectUserResponse, error)

	PermitProjectUserWithResponse(ctx context.Context, projectID ProjectID, body PermitProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitProjectUserResponse, error)

	// ListGlobalRunnersWithResponse request
	ListGlobalRunnersWithResponse(ctx context.Context, params *ListGlobalRunnersParams, reqEditors ...RequestEditorFn) (*ListGlobalRunnersResponse, error)

	// CreateGlobalRunnerWithBodyWithResponse request with any body
	CreateGlobalRunnerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalRunnerResponse, error)

	CreateGlobalRunnerWithResponse(ctx context.Context, body CreateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalRunnerResponse, error)

	// DeleteGlobalRunnerWithResponse request
	DeleteGlobalRunnerWithResponse(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*DeleteGlobalRunnerResponse, error)

	// ShowGlobalRunnerWithResponse request
	ShowGlobalRunnerWithResponse(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*ShowGlobalRunnerResponse, error)

	// UpdateGlobalRunnerWithBodyWithResponse request with any body
	UpdateGlobalRunnerWithBodyWithResponse(ctx context.Context, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalRunnerResponse, error)

	UpdateGlobalRunnerWithResponse(ctx context.Context, runnerID RunnerID, body UpdateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalRunnerResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// ShowUserWithResponse request
	ShowUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*ShowUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// DeleteUserFromGroupWithBodyWithResponse request with any body
	DeleteUserFromGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error)

	DeleteUserFromGroupWithResponse(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error)

	// ListUserGroupsWithResponse request
	ListUserGroupsWithResponse(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error)

	// AttachUserToGroupWithBodyWithResponse request with any body
	AttachUserToGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error)

	AttachUserToGroupWithResponse(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error)

	// PermitUserGroupWithBodyWithResponse request with any body
	PermitUserGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error)

	PermitUserGroupWithResponse(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error)

	// DeleteUserFromProjectWithBodyWithResponse request with any body
	DeleteUserFromProjectWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromProjectResponse, error)

	DeleteUserFromProjectWithResponse(ctx context.Context, userID UserID, body DeleteUserFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromProjectResponse, error)

	// ListUserProjectsWithResponse request
	ListUserProjectsWithResponse(ctx context.Context, userID UserID, params *ListUserProjectsParams, reqEditors ...RequestEditorFn) (*ListUserProjectsResponse, error)

	// AttachUserToProjectWithBodyWithResponse request with any body
	AttachUserToProjectWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToProjectResponse, error)

	AttachUserToProjectWithResponse(ctx context.Context, userID UserID, body AttachUserToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToProjectResponse, error)

	// PermitUserProjectWithBodyWithResponse request with any body
	PermitUserProjectWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserProjectResponse, error)

	PermitUserProjectWithResponse(ctx context.Context, userID UserID, body PermitUserProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserProjectResponse, error)
}

type LoginAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse
	JSON400      *BadRequestError
	JSON401      *BadCredentialsError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LoginAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProvidersResponse
}

// Status returns HTTPResponse.Status
func (r ListProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RedirectAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *BadRequestError
	JSON401      *InvalidTokenError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RedirectAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RedirectAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshResponse
	JSON401      *InvalidTokenError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RefreshAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyResponse
	JSON401      *InvalidTokenError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r VerifyAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CallbackProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CallbackProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CallbackProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RequestProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGlobalEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalEventsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGlobalEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGlobalEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupFromProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupFromProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupFromProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupProjectsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGroupProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachGroupToProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachGroupToProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachGroupToProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitGroupProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitGroupProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitGroupProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupUsersResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGroupUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachGroupToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachGroupToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachGroupToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitGroupUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitGroupUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitGroupUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TokenProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCredentialsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCredentialResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCredentialResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCredentialResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectEnvironmentSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentSecretResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectEnvironmentSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectEnvironmentSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectEnvironmentSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectEnvironmentSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectEnvironmentSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectEnvironmentSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentSecretResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectEnvironmentSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectEnvironmentSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectEnvironmentValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentValueResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectEnvironmentValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectEnvironmentValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectEnvironmentValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectEnvironmentValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectEnvironmentValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectEnvironmentValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEnvironmentValueResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectEnvironmentValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectEnvironmentValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectEventsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectExecutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectExecutionsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectExecutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectExecutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectExecutionResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectExecutionResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OutputProjectExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectOutputResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r OutputProjectExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OutputProjectExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PurgeProjectExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PurgeProjectExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PurgeProjectExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectGroupsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachProjectToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachProjectToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachProjectToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitProjectGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitProjectGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitProjectGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectInventoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectInventoriesResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectInventoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectInventoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectInventoryResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectInventoryResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectInventoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectInventoryResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectInventoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectInventoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRepositoriesResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRepositoryResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRepositoryResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRepositoryResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectRunnersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRunnersResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectRunnersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectRunnersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRunnerResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRunnerResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectRunnerResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectSchedulesResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectScheduleResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectScheduleResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectScheduleResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplatesResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplateResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProjectTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplateResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProjectTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProjectTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplateResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectTemplateSurveyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplateSurveyResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectTemplateSurveyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectTemplateSurveyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectTemplateSurveyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectTemplateSurveyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectTemplateSurveyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectTemplateSurveyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplateSurveyResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectTemplateSurveyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectTemplateSurveyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectTemplateVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplateVaultResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProjectTemplateVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectTemplateVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectTemplateVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectTemplateVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectTemplateVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectTemplateVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectTemplateVaultResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectTemplateVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectTemplateVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectUsersResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListProjectUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachProjectToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachProjectToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachProjectToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitProjectUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitProjectUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitProjectUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGlobalRunnersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalRunnersResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGlobalRunnersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGlobalRunnersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGlobalRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalRunnerResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateGlobalRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGlobalRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGlobalRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGlobalRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGlobalRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowGlobalRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalRunnerResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowGlobalRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowGlobalRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGlobalRunnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalRunnerResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateGlobalRunnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGlobalRunnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserGroupsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUserGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitUserGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserProjectsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUserProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachUserToProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitUserProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LoginAuthWithBodyWithResponse request with arbitrary body returning *LoginAuthResponse
func (c *ClientWithResponses) LoginAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error) {
	rsp, err := c.LoginAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginAuthResponse(rsp)
}

func (c *ClientWithResponses) LoginAuthWithResponse(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error) {
	rsp, err := c.LoginAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginAuthResponse(rsp)
}

// ListProvidersWithResponse request returning *ListProvidersResponse
func (c *ClientWithResponses) ListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error) {
	rsp, err := c.ListProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProvidersResponse(rsp)
}

// RedirectAuthWithBodyWithResponse request with arbitrary body returning *RedirectAuthResponse
func (c *ClientWithResponses) RedirectAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error) {
	rsp, err := c.RedirectAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRedirectAuthResponse(rsp)
}

func (c *ClientWithResponses) RedirectAuthWithResponse(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error) {
	rsp, err := c.RedirectAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRedirectAuthResponse(rsp)
}

// RefreshAuthWithResponse request returning *RefreshAuthResponse
func (c *ClientWithResponses) RefreshAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshAuthResponse, error) {
	rsp, err := c.RefreshAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAuthResponse(rsp)
}

// VerifyAuthWithResponse request returning *VerifyAuthResponse
func (c *ClientWithResponses) VerifyAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VerifyAuthResponse, error) {
	rsp, err := c.VerifyAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyAuthResponse(rsp)
}

// CallbackProviderWithResponse request returning *CallbackProviderResponse
func (c *ClientWithResponses) CallbackProviderWithResponse(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*CallbackProviderResponse, error) {
	rsp, err := c.CallbackProvider(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCallbackProviderResponse(rsp)
}

// RequestProviderWithResponse request returning *RequestProviderResponse
func (c *ClientWithResponses) RequestProviderWithResponse(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*RequestProviderResponse, error) {
	rsp, err := c.RequestProvider(ctx, provider, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestProviderResponse(rsp)
}

// ListGlobalEventsWithResponse request returning *ListGlobalEventsResponse
func (c *ClientWithResponses) ListGlobalEventsWithResponse(ctx context.Context, params *ListGlobalEventsParams, reqEditors ...RequestEditorFn) (*ListGlobalEventsResponse, error) {
	rsp, err := c.ListGlobalEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGlobalEventsResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// ShowGroupWithResponse request returning *ShowGroupResponse
func (c *ClientWithResponses) ShowGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*ShowGroupResponse, error) {
	rsp, err := c.ShowGroup(ctx, groupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// DeleteGroupFromProjectWithBodyWithResponse request with arbitrary body returning *DeleteGroupFromProjectResponse
func (c *ClientWithResponses) DeleteGroupFromProjectWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromProjectResponse, error) {
	rsp, err := c.DeleteGroupFromProjectWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromProjectResponse(rsp)
}

func (c *ClientWithResponses) DeleteGroupFromProjectWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromProjectResponse, error) {
	rsp, err := c.DeleteGroupFromProject(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromProjectResponse(rsp)
}

// ListGroupProjectsWithResponse request returning *ListGroupProjectsResponse
func (c *ClientWithResponses) ListGroupProjectsWithResponse(ctx context.Context, groupID GroupID, params *ListGroupProjectsParams, reqEditors ...RequestEditorFn) (*ListGroupProjectsResponse, error) {
	rsp, err := c.ListGroupProjects(ctx, groupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupProjectsResponse(rsp)
}

// AttachGroupToProjectWithBodyWithResponse request with arbitrary body returning *AttachGroupToProjectResponse
func (c *ClientWithResponses) AttachGroupToProjectWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToProjectResponse, error) {
	rsp, err := c.AttachGroupToProjectWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToProjectResponse(rsp)
}

func (c *ClientWithResponses) AttachGroupToProjectWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToProjectResponse, error) {
	rsp, err := c.AttachGroupToProject(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToProjectResponse(rsp)
}

// PermitGroupProjectWithBodyWithResponse request with arbitrary body returning *PermitGroupProjectResponse
func (c *ClientWithResponses) PermitGroupProjectWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupProjectResponse, error) {
	rsp, err := c.PermitGroupProjectWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupProjectResponse(rsp)
}

func (c *ClientWithResponses) PermitGroupProjectWithResponse(ctx context.Context, groupID GroupID, body PermitGroupProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupProjectResponse, error) {
	rsp, err := c.PermitGroupProject(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupProjectResponse(rsp)
}

// DeleteGroupFromUserWithBodyWithResponse request with arbitrary body returning *DeleteGroupFromUserResponse
func (c *ClientWithResponses) DeleteGroupFromUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error) {
	rsp, err := c.DeleteGroupFromUserWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteGroupFromUserWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error) {
	rsp, err := c.DeleteGroupFromUser(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromUserResponse(rsp)
}

// ListGroupUsersWithResponse request returning *ListGroupUsersResponse
func (c *ClientWithResponses) ListGroupUsersWithResponse(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*ListGroupUsersResponse, error) {
	rsp, err := c.ListGroupUsers(ctx, groupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupUsersResponse(rsp)
}

// AttachGroupToUserWithBodyWithResponse request with arbitrary body returning *AttachGroupToUserResponse
func (c *ClientWithResponses) AttachGroupToUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error) {
	rsp, err := c.AttachGroupToUserWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachGroupToUserWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error) {
	rsp, err := c.AttachGroupToUser(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToUserResponse(rsp)
}

// PermitGroupUserWithBodyWithResponse request with arbitrary body returning *PermitGroupUserResponse
func (c *ClientWithResponses) PermitGroupUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error) {
	rsp, err := c.PermitGroupUserWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupUserResponse(rsp)
}

func (c *ClientWithResponses) PermitGroupUserWithResponse(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error) {
	rsp, err := c.PermitGroupUser(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupUserResponse(rsp)
}

// ShowProfileWithResponse request returning *ShowProfileResponse
func (c *ClientWithResponses) ShowProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShowProfileResponse, error) {
	rsp, err := c.ShowProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProfileResponse(rsp)
}

// UpdateProfileWithBodyWithResponse request with arbitrary body returning *UpdateProfileResponse
func (c *ClientWithResponses) UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

// TokenProfileWithResponse request returning *TokenProfileResponse
func (c *ClientWithResponses) TokenProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokenProfileResponse, error) {
	rsp, err := c.TokenProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenProfileResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// ShowProjectWithResponse request returning *ShowProjectResponse
func (c *ClientWithResponses) ShowProjectWithResponse(ctx context.Context, projectID ProjectID, reqEditors ...RequestEditorFn) (*ShowProjectResponse, error) {
	rsp, err := c.ShowProject(ctx, projectID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, projectID ProjectID, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// ListProjectCredentialsWithResponse request returning *ListProjectCredentialsResponse
func (c *ClientWithResponses) ListProjectCredentialsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectCredentialsParams, reqEditors ...RequestEditorFn) (*ListProjectCredentialsResponse, error) {
	rsp, err := c.ListProjectCredentials(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectCredentialsResponse(rsp)
}

// CreateProjectCredentialWithBodyWithResponse request with arbitrary body returning *CreateProjectCredentialResponse
func (c *ClientWithResponses) CreateProjectCredentialWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectCredentialResponse, error) {
	rsp, err := c.CreateProjectCredentialWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectCredentialResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectCredentialResponse, error) {
	rsp, err := c.CreateProjectCredential(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectCredentialResponse(rsp)
}

// DeleteProjectCredentialWithResponse request returning *DeleteProjectCredentialResponse
func (c *ClientWithResponses) DeleteProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*DeleteProjectCredentialResponse, error) {
	rsp, err := c.DeleteProjectCredential(ctx, projectID, credentialID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectCredentialResponse(rsp)
}

// ShowProjectCredentialWithResponse request returning *ShowProjectCredentialResponse
func (c *ClientWithResponses) ShowProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*ShowProjectCredentialResponse, error) {
	rsp, err := c.ShowProjectCredential(ctx, projectID, credentialID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectCredentialResponse(rsp)
}

// UpdateProjectCredentialWithBodyWithResponse request with arbitrary body returning *UpdateProjectCredentialResponse
func (c *ClientWithResponses) UpdateProjectCredentialWithBodyWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectCredentialResponse, error) {
	rsp, err := c.UpdateProjectCredentialWithBody(ctx, projectID, credentialID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectCredentialResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectCredentialWithResponse(ctx context.Context, projectID ProjectID, credentialID CredentialID, body UpdateProjectCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectCredentialResponse, error) {
	rsp, err := c.UpdateProjectCredential(ctx, projectID, credentialID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectCredentialResponse(rsp)
}

// ListProjectEnvironmentsWithResponse request returning *ListProjectEnvironmentsResponse
func (c *ClientWithResponses) ListProjectEnvironmentsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectEnvironmentsParams, reqEditors ...RequestEditorFn) (*ListProjectEnvironmentsResponse, error) {
	rsp, err := c.ListProjectEnvironments(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectEnvironmentsResponse(rsp)
}

// CreateProjectEnvironmentWithBodyWithResponse request with arbitrary body returning *CreateProjectEnvironmentResponse
func (c *ClientWithResponses) CreateProjectEnvironmentWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentResponse, error) {
	rsp, err := c.CreateProjectEnvironmentWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentResponse, error) {
	rsp, err := c.CreateProjectEnvironment(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEnvironmentResponse(rsp)
}

// DeleteProjectEnvironmentWithResponse request returning *DeleteProjectEnvironmentResponse
func (c *ClientWithResponses) DeleteProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*DeleteProjectEnvironmentResponse, error) {
	rsp, err := c.DeleteProjectEnvironment(ctx, projectID, environmentID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectEnvironmentResponse(rsp)
}

// ShowProjectEnvironmentWithResponse request returning *ShowProjectEnvironmentResponse
func (c *ClientWithResponses) ShowProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, reqEditors ...RequestEditorFn) (*ShowProjectEnvironmentResponse, error) {
	rsp, err := c.ShowProjectEnvironment(ctx, projectID, environmentID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectEnvironmentResponse(rsp)
}

// UpdateProjectEnvironmentWithBodyWithResponse request with arbitrary body returning *UpdateProjectEnvironmentResponse
func (c *ClientWithResponses) UpdateProjectEnvironmentWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentResponse, error) {
	rsp, err := c.UpdateProjectEnvironmentWithBody(ctx, projectID, environmentID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectEnvironmentWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body UpdateProjectEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentResponse, error) {
	rsp, err := c.UpdateProjectEnvironment(ctx, projectID, environmentID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEnvironmentResponse(rsp)
}

// CreateProjectEnvironmentSecretWithBodyWithResponse request with arbitrary body returning *CreateProjectEnvironmentSecretResponse
func (c *ClientWithResponses) CreateProjectEnvironmentSecretWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentSecretResponse, error) {
	rsp, err := c.CreateProjectEnvironmentSecretWithBody(ctx, projectID, environmentID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEnvironmentSecretResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectEnvironmentSecretWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentSecretResponse, error) {
	rsp, err := c.CreateProjectEnvironmentSecret(ctx, projectID, environmentID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEnvironmentSecretResponse(rsp)
}

// DeleteProjectEnvironmentSecretWithResponse request returning *DeleteProjectEnvironmentSecretResponse
func (c *ClientWithResponses) DeleteProjectEnvironmentSecretWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, reqEditors ...RequestEditorFn) (*DeleteProjectEnvironmentSecretResponse, error) {
	rsp, err := c.DeleteProjectEnvironmentSecret(ctx, projectID, environmentID, secretID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectEnvironmentSecretResponse(rsp)
}

// UpdateProjectEnvironmentSecretWithBodyWithResponse request with arbitrary body returning *UpdateProjectEnvironmentSecretResponse
func (c *ClientWithResponses) UpdateProjectEnvironmentSecretWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentSecretResponse, error) {
	rsp, err := c.UpdateProjectEnvironmentSecretWithBody(ctx, projectID, environmentID, secretID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEnvironmentSecretResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectEnvironmentSecretWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, secretID SecretID, body UpdateProjectEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentSecretResponse, error) {
	rsp, err := c.UpdateProjectEnvironmentSecret(ctx, projectID, environmentID, secretID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEnvironmentSecretResponse(rsp)
}

// CreateProjectEnvironmentValueWithBodyWithResponse request with arbitrary body returning *CreateProjectEnvironmentValueResponse
func (c *ClientWithResponses) CreateProjectEnvironmentValueWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentValueResponse, error) {
	rsp, err := c.CreateProjectEnvironmentValueWithBody(ctx, projectID, environmentID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEnvironmentValueResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectEnvironmentValueWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, body CreateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEnvironmentValueResponse, error) {
	rsp, err := c.CreateProjectEnvironmentValue(ctx, projectID, environmentID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEnvironmentValueResponse(rsp)
}

// DeleteProjectEnvironmentValueWithResponse request returning *DeleteProjectEnvironmentValueResponse
func (c *ClientWithResponses) DeleteProjectEnvironmentValueWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, reqEditors ...RequestEditorFn) (*DeleteProjectEnvironmentValueResponse, error) {
	rsp, err := c.DeleteProjectEnvironmentValue(ctx, projectID, environmentID, valueID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectEnvironmentValueResponse(rsp)
}

// UpdateProjectEnvironmentValueWithBodyWithResponse request with arbitrary body returning *UpdateProjectEnvironmentValueResponse
func (c *ClientWithResponses) UpdateProjectEnvironmentValueWithBodyWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentValueResponse, error) {
	rsp, err := c.UpdateProjectEnvironmentValueWithBody(ctx, projectID, environmentID, valueID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEnvironmentValueResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectEnvironmentValueWithResponse(ctx context.Context, projectID ProjectID, environmentID EnvironmentID, valueID ValueID, body UpdateProjectEnvironmentValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEnvironmentValueResponse, error) {
	rsp, err := c.UpdateProjectEnvironmentValue(ctx, projectID, environmentID, valueID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEnvironmentValueResponse(rsp)
}

// ListProjectEventsWithResponse request returning *ListProjectEventsResponse
func (c *ClientWithResponses) ListProjectEventsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectEventsParams, reqEditors ...RequestEditorFn) (*ListProjectEventsResponse, error) {
	rsp, err := c.ListProjectEvents(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectEventsResponse(rsp)
}

// ListProjectExecutionsWithResponse request returning *ListProjectExecutionsResponse
func (c *ClientWithResponses) ListProjectExecutionsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectExecutionsParams, reqEditors ...RequestEditorFn) (*ListProjectExecutionsResponse, error) {
	rsp, err := c.ListProjectExecutions(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectExecutionsResponse(rsp)
}

// CreateProjectExecutionWithBodyWithResponse request with arbitrary body returning *CreateProjectExecutionResponse
func (c *ClientWithResponses) CreateProjectExecutionWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectExecutionResponse, error) {
	rsp, err := c.CreateProjectExecutionWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectExecutionResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectExecutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectExecutionResponse, error) {
	rsp, err := c.CreateProjectExecution(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectExecutionResponse(rsp)
}

// DeleteProjectExecutionWithResponse request returning *DeleteProjectExecutionResponse
func (c *ClientWithResponses) DeleteProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*DeleteProjectExecutionResponse, error) {
	rsp, err := c.DeleteProjectExecution(ctx, projectID, executionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectExecutionResponse(rsp)
}

// ShowProjectExecutionWithResponse request returning *ShowProjectExecutionResponse
func (c *ClientWithResponses) ShowProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*ShowProjectExecutionResponse, error) {
	rsp, err := c.ShowProjectExecution(ctx, projectID, executionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectExecutionResponse(rsp)
}

// OutputProjectExecutionWithResponse request returning *OutputProjectExecutionResponse
func (c *ClientWithResponses) OutputProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*OutputProjectExecutionResponse, error) {
	rsp, err := c.OutputProjectExecution(ctx, projectID, executionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOutputProjectExecutionResponse(rsp)
}

// PurgeProjectExecutionWithResponse request returning *PurgeProjectExecutionResponse
func (c *ClientWithResponses) PurgeProjectExecutionWithResponse(ctx context.Context, projectID ProjectID, executionID ExecutionID, reqEditors ...RequestEditorFn) (*PurgeProjectExecutionResponse, error) {
	rsp, err := c.PurgeProjectExecution(ctx, projectID, executionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePurgeProjectExecutionResponse(rsp)
}

// DeleteProjectFromGroupWithBodyWithResponse request with arbitrary body returning *DeleteProjectFromGroupResponse
func (c *ClientWithResponses) DeleteProjectFromGroupWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProjectFromGroupResponse, error) {
	rsp, err := c.DeleteProjectFromGroupWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectFromGroupResponse(rsp)
}

func (c *ClientWithResponses) DeleteProjectFromGroupWithResponse(ctx context.Context, projectID ProjectID, body DeleteProjectFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProjectFromGroupResponse, error) {
	rsp, err := c.DeleteProjectFromGroup(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectFromGroupResponse(rsp)
}

// ListProjectGroupsWithResponse request returning *ListProjectGroupsResponse
func (c *ClientWithResponses) ListProjectGroupsWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectGroupsParams, reqEditors ...RequestEditorFn) (*ListProjectGroupsResponse, error) {
	rsp, err := c.ListProjectGroups(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectGroupsResponse(rsp)
}

// AttachProjectToGroupWithBodyWithResponse request with arbitrary body returning *AttachProjectToGroupResponse
func (c *ClientWithResponses) AttachProjectToGroupWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachProjectToGroupResponse, error) {
	rsp, err := c.AttachProjectToGroupWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachProjectToGroupResponse(rsp)
}

func (c *ClientWithResponses) AttachProjectToGroupWithResponse(ctx context.Context, projectID ProjectID, body AttachProjectToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachProjectToGroupResponse, error) {
	rsp, err := c.AttachProjectToGroup(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachProjectToGroupResponse(rsp)
}

// PermitProjectGroupWithBodyWithResponse request with arbitrary body returning *PermitProjectGroupResponse
func (c *ClientWithResponses) PermitProjectGroupWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitProjectGroupResponse, error) {
	rsp, err := c.PermitProjectGroupWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitProjectGroupResponse(rsp)
}

func (c *ClientWithResponses) PermitProjectGroupWithResponse(ctx context.Context, projectID ProjectID, body PermitProjectGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitProjectGroupResponse, error) {
	rsp, err := c.PermitProjectGroup(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitProjectGroupResponse(rsp)
}

// ListProjectInventoriesWithResponse request returning *ListProjectInventoriesResponse
func (c *ClientWithResponses) ListProjectInventoriesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectInventoriesParams, reqEditors ...RequestEditorFn) (*ListProjectInventoriesResponse, error) {
	rsp, err := c.ListProjectInventories(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectInventoriesResponse(rsp)
}

// CreateProjectInventoryWithBodyWithResponse request with arbitrary body returning *CreateProjectInventoryResponse
func (c *ClientWithResponses) CreateProjectInventoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectInventoryResponse, error) {
	rsp, err := c.CreateProjectInventoryWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectInventoryResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectInventoryResponse, error) {
	rsp, err := c.CreateProjectInventory(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectInventoryResponse(rsp)
}

// DeleteProjectInventoryWithResponse request returning *DeleteProjectInventoryResponse
func (c *ClientWithResponses) DeleteProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*DeleteProjectInventoryResponse, error) {
	rsp, err := c.DeleteProjectInventory(ctx, projectID, inventoryID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectInventoryResponse(rsp)
}

// ShowProjectInventoryWithResponse request returning *ShowProjectInventoryResponse
func (c *ClientWithResponses) ShowProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, reqEditors ...RequestEditorFn) (*ShowProjectInventoryResponse, error) {
	rsp, err := c.ShowProjectInventory(ctx, projectID, inventoryID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectInventoryResponse(rsp)
}

// UpdateProjectInventoryWithBodyWithResponse request with arbitrary body returning *UpdateProjectInventoryResponse
func (c *ClientWithResponses) UpdateProjectInventoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectInventoryResponse, error) {
	rsp, err := c.UpdateProjectInventoryWithBody(ctx, projectID, inventoryID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectInventoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectInventoryWithResponse(ctx context.Context, projectID ProjectID, inventoryID InventoryID, body UpdateProjectInventoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectInventoryResponse, error) {
	rsp, err := c.UpdateProjectInventory(ctx, projectID, inventoryID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectInventoryResponse(rsp)
}

// ListProjectRepositoriesWithResponse request returning *ListProjectRepositoriesResponse
func (c *ClientWithResponses) ListProjectRepositoriesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectRepositoriesParams, reqEditors ...RequestEditorFn) (*ListProjectRepositoriesResponse, error) {
	rsp, err := c.ListProjectRepositories(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectRepositoriesResponse(rsp)
}

// CreateProjectRepositoryWithBodyWithResponse request with arbitrary body returning *CreateProjectRepositoryResponse
func (c *ClientWithResponses) CreateProjectRepositoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectRepositoryResponse, error) {
	rsp, err := c.CreateProjectRepositoryWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectRepositoryResponse, error) {
	rsp, err := c.CreateProjectRepository(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectRepositoryResponse(rsp)
}

// DeleteProjectRepositoryWithResponse request returning *DeleteProjectRepositoryResponse
func (c *ClientWithResponses) DeleteProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*DeleteProjectRepositoryResponse, error) {
	rsp, err := c.DeleteProjectRepository(ctx, projectID, repositoryID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectRepositoryResponse(rsp)
}

// ShowProjectRepositoryWithResponse request returning *ShowProjectRepositoryResponse
func (c *ClientWithResponses) ShowProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, reqEditors ...RequestEditorFn) (*ShowProjectRepositoryResponse, error) {
	rsp, err := c.ShowProjectRepository(ctx, projectID, repositoryID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectRepositoryResponse(rsp)
}

// UpdateProjectRepositoryWithBodyWithResponse request with arbitrary body returning *UpdateProjectRepositoryResponse
func (c *ClientWithResponses) UpdateProjectRepositoryWithBodyWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectRepositoryResponse, error) {
	rsp, err := c.UpdateProjectRepositoryWithBody(ctx, projectID, repositoryID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectRepositoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectRepositoryWithResponse(ctx context.Context, projectID ProjectID, repositoryID RepositoryID, body UpdateProjectRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectRepositoryResponse, error) {
	rsp, err := c.UpdateProjectRepository(ctx, projectID, repositoryID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectRepositoryResponse(rsp)
}

// ListProjectRunnersWithResponse request returning *ListProjectRunnersResponse
func (c *ClientWithResponses) ListProjectRunnersWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectRunnersParams, reqEditors ...RequestEditorFn) (*ListProjectRunnersResponse, error) {
	rsp, err := c.ListProjectRunners(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectRunnersResponse(rsp)
}

// CreateProjectRunnerWithBodyWithResponse request with arbitrary body returning *CreateProjectRunnerResponse
func (c *ClientWithResponses) CreateProjectRunnerWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectRunnerResponse, error) {
	rsp, err := c.CreateProjectRunnerWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectRunnerResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectRunnerResponse, error) {
	rsp, err := c.CreateProjectRunner(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectRunnerResponse(rsp)
}

// DeleteProjectRunnerWithResponse request returning *DeleteProjectRunnerResponse
func (c *ClientWithResponses) DeleteProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*DeleteProjectRunnerResponse, error) {
	rsp, err := c.DeleteProjectRunner(ctx, projectID, runnerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectRunnerResponse(rsp)
}

// ShowProjectRunnerWithResponse request returning *ShowProjectRunnerResponse
func (c *ClientWithResponses) ShowProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, reqEditors ...RequestEditorFn) (*ShowProjectRunnerResponse, error) {
	rsp, err := c.ShowProjectRunner(ctx, projectID, runnerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectRunnerResponse(rsp)
}

// UpdateProjectRunnerWithBodyWithResponse request with arbitrary body returning *UpdateProjectRunnerResponse
func (c *ClientWithResponses) UpdateProjectRunnerWithBodyWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectRunnerResponse, error) {
	rsp, err := c.UpdateProjectRunnerWithBody(ctx, projectID, runnerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectRunnerResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectRunnerWithResponse(ctx context.Context, projectID ProjectID, runnerID RunnerID, body UpdateProjectRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectRunnerResponse, error) {
	rsp, err := c.UpdateProjectRunner(ctx, projectID, runnerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectRunnerResponse(rsp)
}

// ListProjectSchedulesWithResponse request returning *ListProjectSchedulesResponse
func (c *ClientWithResponses) ListProjectSchedulesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectSchedulesParams, reqEditors ...RequestEditorFn) (*ListProjectSchedulesResponse, error) {
	rsp, err := c.ListProjectSchedules(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectSchedulesResponse(rsp)
}

// CreateProjectScheduleWithBodyWithResponse request with arbitrary body returning *CreateProjectScheduleResponse
func (c *ClientWithResponses) CreateProjectScheduleWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectScheduleResponse, error) {
	rsp, err := c.CreateProjectScheduleWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectScheduleResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectScheduleResponse, error) {
	rsp, err := c.CreateProjectSchedule(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectScheduleResponse(rsp)
}

// DeleteProjectScheduleWithResponse request returning *DeleteProjectScheduleResponse
func (c *ClientWithResponses) DeleteProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*DeleteProjectScheduleResponse, error) {
	rsp, err := c.DeleteProjectSchedule(ctx, projectID, scheduleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectScheduleResponse(rsp)
}

// ShowProjectScheduleWithResponse request returning *ShowProjectScheduleResponse
func (c *ClientWithResponses) ShowProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, reqEditors ...RequestEditorFn) (*ShowProjectScheduleResponse, error) {
	rsp, err := c.ShowProjectSchedule(ctx, projectID, scheduleID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectScheduleResponse(rsp)
}

// UpdateProjectScheduleWithBodyWithResponse request with arbitrary body returning *UpdateProjectScheduleResponse
func (c *ClientWithResponses) UpdateProjectScheduleWithBodyWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectScheduleResponse, error) {
	rsp, err := c.UpdateProjectScheduleWithBody(ctx, projectID, scheduleID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectScheduleWithResponse(ctx context.Context, projectID ProjectID, scheduleID ScheduleID, body UpdateProjectScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectScheduleResponse, error) {
	rsp, err := c.UpdateProjectSchedule(ctx, projectID, scheduleID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectScheduleResponse(rsp)
}

// ListProjectTemplatesWithResponse request returning *ListProjectTemplatesResponse
func (c *ClientWithResponses) ListProjectTemplatesWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectTemplatesParams, reqEditors ...RequestEditorFn) (*ListProjectTemplatesResponse, error) {
	rsp, err := c.ListProjectTemplates(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectTemplatesResponse(rsp)
}

// CreateProjectTemplateWithBodyWithResponse request with arbitrary body returning *CreateProjectTemplateResponse
func (c *ClientWithResponses) CreateProjectTemplateWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectTemplateResponse, error) {
	rsp, err := c.CreateProjectTemplateWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, body CreateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectTemplateResponse, error) {
	rsp, err := c.CreateProjectTemplate(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectTemplateResponse(rsp)
}

// DeleteProjectTemplateWithResponse request returning *DeleteProjectTemplateResponse
func (c *ClientWithResponses) DeleteProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*DeleteProjectTemplateResponse, error) {
	rsp, err := c.DeleteProjectTemplate(ctx, projectID, templateID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectTemplateResponse(rsp)
}

// ShowProjectTemplateWithResponse request returning *ShowProjectTemplateResponse
func (c *ClientWithResponses) ShowProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, reqEditors ...RequestEditorFn) (*ShowProjectTemplateResponse, error) {
	rsp, err := c.ShowProjectTemplate(ctx, projectID, templateID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProjectTemplateResponse(rsp)
}

// UpdateProjectTemplateWithBodyWithResponse request with arbitrary body returning *UpdateProjectTemplateResponse
func (c *ClientWithResponses) UpdateProjectTemplateWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateResponse, error) {
	rsp, err := c.UpdateProjectTemplateWithBody(ctx, projectID, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectTemplateWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, body UpdateProjectTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateResponse, error) {
	rsp, err := c.UpdateProjectTemplate(ctx, projectID, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectTemplateResponse(rsp)
}

// CreateProjectTemplateSurveyWithBodyWithResponse request with arbitrary body returning *CreateProjectTemplateSurveyResponse
func (c *ClientWithResponses) CreateProjectTemplateSurveyWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectTemplateSurveyResponse, error) {
	rsp, err := c.CreateProjectTemplateSurveyWithBody(ctx, projectID, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectTemplateSurveyResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectTemplateSurveyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectTemplateSurveyResponse, error) {
	rsp, err := c.CreateProjectTemplateSurvey(ctx, projectID, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectTemplateSurveyResponse(rsp)
}

// DeleteProjectTemplateSurveyWithResponse request returning *DeleteProjectTemplateSurveyResponse
func (c *ClientWithResponses) DeleteProjectTemplateSurveyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, reqEditors ...RequestEditorFn) (*DeleteProjectTemplateSurveyResponse, error) {
	rsp, err := c.DeleteProjectTemplateSurvey(ctx, projectID, templateID, surveyID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectTemplateSurveyResponse(rsp)
}

// UpdateProjectTemplateSurveyWithBodyWithResponse request with arbitrary body returning *UpdateProjectTemplateSurveyResponse
func (c *ClientWithResponses) UpdateProjectTemplateSurveyWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateSurveyResponse, error) {
	rsp, err := c.UpdateProjectTemplateSurveyWithBody(ctx, projectID, templateID, surveyID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectTemplateSurveyResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectTemplateSurveyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, surveyID SurveyID, body UpdateProjectTemplateSurveyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateSurveyResponse, error) {
	rsp, err := c.UpdateProjectTemplateSurvey(ctx, projectID, templateID, surveyID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectTemplateSurveyResponse(rsp)
}

// CreateProjectTemplateVaultWithBodyWithResponse request with arbitrary body returning *CreateProjectTemplateVaultResponse
func (c *ClientWithResponses) CreateProjectTemplateVaultWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectTemplateVaultResponse, error) {
	rsp, err := c.CreateProjectTemplateVaultWithBody(ctx, projectID, templateID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectTemplateVaultResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectTemplateVaultWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, body CreateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectTemplateVaultResponse, error) {
	rsp, err := c.CreateProjectTemplateVault(ctx, projectID, templateID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectTemplateVaultResponse(rsp)
}

// DeleteProjectTemplateVaultWithResponse request returning *DeleteProjectTemplateVaultResponse
func (c *ClientWithResponses) DeleteProjectTemplateVaultWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, reqEditors ...RequestEditorFn) (*DeleteProjectTemplateVaultResponse, error) {
	rsp, err := c.DeleteProjectTemplateVault(ctx, projectID, templateID, vaultID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectTemplateVaultResponse(rsp)
}

// UpdateProjectTemplateVaultWithBodyWithResponse request with arbitrary body returning *UpdateProjectTemplateVaultResponse
func (c *ClientWithResponses) UpdateProjectTemplateVaultWithBodyWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateVaultResponse, error) {
	rsp, err := c.UpdateProjectTemplateVaultWithBody(ctx, projectID, templateID, vaultID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectTemplateVaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectTemplateVaultWithResponse(ctx context.Context, projectID ProjectID, templateID TemplateID, vaultID VaultID, body UpdateProjectTemplateVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectTemplateVaultResponse, error) {
	rsp, err := c.UpdateProjectTemplateVault(ctx, projectID, templateID, vaultID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectTemplateVaultResponse(rsp)
}

// DeleteProjectFromUserWithBodyWithResponse request with arbitrary body returning *DeleteProjectFromUserResponse
func (c *ClientWithResponses) DeleteProjectFromUserWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteProjectFromUserResponse, error) {
	rsp, err := c.DeleteProjectFromUserWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteProjectFromUserWithResponse(ctx context.Context, projectID ProjectID, body DeleteProjectFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteProjectFromUserResponse, error) {
	rsp, err := c.DeleteProjectFromUser(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectFromUserResponse(rsp)
}

// ListProjectUsersWithResponse request returning *ListProjectUsersResponse
func (c *ClientWithResponses) ListProjectUsersWithResponse(ctx context.Context, projectID ProjectID, params *ListProjectUsersParams, reqEditors ...RequestEditorFn) (*ListProjectUsersResponse, error) {
	rsp, err := c.ListProjectUsers(ctx, projectID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectUsersResponse(rsp)
}

// AttachProjectToUserWithBodyWithResponse request with arbitrary body returning *AttachProjectToUserResponse
func (c *ClientWithResponses) AttachProjectToUserWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachProjectToUserResponse, error) {
	rsp, err := c.AttachProjectToUserWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachProjectToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachProjectToUserWithResponse(ctx context.Context, projectID ProjectID, body AttachProjectToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachProjectToUserResponse, error) {
	rsp, err := c.AttachProjectToUser(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachProjectToUserResponse(rsp)
}

// PermitProjectUserWithBodyWithResponse request with arbitrary body returning *PermitProjectUserResponse
func (c *ClientWithResponses) PermitProjectUserWithBodyWithResponse(ctx context.Context, projectID ProjectID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitProjectUserResponse, error) {
	rsp, err := c.PermitProjectUserWithBody(ctx, projectID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitProjectUserResponse(rsp)
}

func (c *ClientWithResponses) PermitProjectUserWithResponse(ctx context.Context, projectID ProjectID, body PermitProjectUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitProjectUserResponse, error) {
	rsp, err := c.PermitProjectUser(ctx, projectID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitProjectUserResponse(rsp)
}

// ListGlobalRunnersWithResponse request returning *ListGlobalRunnersResponse
func (c *ClientWithResponses) ListGlobalRunnersWithResponse(ctx context.Context, params *ListGlobalRunnersParams, reqEditors ...RequestEditorFn) (*ListGlobalRunnersResponse, error) {
	rsp, err := c.ListGlobalRunners(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGlobalRunnersResponse(rsp)
}

// CreateGlobalRunnerWithBodyWithResponse request with arbitrary body returning *CreateGlobalRunnerResponse
func (c *ClientWithResponses) CreateGlobalRunnerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalRunnerResponse, error) {
	rsp, err := c.CreateGlobalRunnerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalRunnerResponse(rsp)
}

func (c *ClientWithResponses) CreateGlobalRunnerWithResponse(ctx context.Context, body CreateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalRunnerResponse, error) {
	rsp, err := c.CreateGlobalRunner(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalRunnerResponse(rsp)
}

// DeleteGlobalRunnerWithResponse request returning *DeleteGlobalRunnerResponse
func (c *ClientWithResponses) DeleteGlobalRunnerWithResponse(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*DeleteGlobalRunnerResponse, error) {
	rsp, err := c.DeleteGlobalRunner(ctx, runnerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGlobalRunnerResponse(rsp)
}

// ShowGlobalRunnerWithResponse request returning *ShowGlobalRunnerResponse
func (c *ClientWithResponses) ShowGlobalRunnerWithResponse(ctx context.Context, runnerID RunnerID, reqEditors ...RequestEditorFn) (*ShowGlobalRunnerResponse, error) {
	rsp, err := c.ShowGlobalRunner(ctx, runnerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowGlobalRunnerResponse(rsp)
}

// UpdateGlobalRunnerWithBodyWithResponse request with arbitrary body returning *UpdateGlobalRunnerResponse
func (c *ClientWithResponses) UpdateGlobalRunnerWithBodyWithResponse(ctx context.Context, runnerID RunnerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalRunnerResponse, error) {
	rsp, err := c.UpdateGlobalRunnerWithBody(ctx, runnerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalRunnerResponse(rsp)
}

func (c *ClientWithResponses) UpdateGlobalRunnerWithResponse(ctx context.Context, runnerID RunnerID, body UpdateGlobalRunnerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalRunnerResponse, error) {
	rsp, err := c.UpdateGlobalRunner(ctx, runnerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalRunnerResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// ShowUserWithResponse request returning *ShowUserResponse
func (c *ClientWithResponses) ShowUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*ShowUserResponse, error) {
	rsp, err := c.ShowUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// DeleteUserFromGroupWithBodyWithResponse request with arbitrary body returning *DeleteUserFromGroupResponse
func (c *ClientWithResponses) DeleteUserFromGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error) {
	rsp, err := c.DeleteUserFromGroupWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromGroupResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromGroupWithResponse(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error) {
	rsp, err := c.DeleteUserFromGroup(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromGroupResponse(rsp)
}

// ListUserGroupsWithResponse request returning *ListUserGroupsResponse
func (c *ClientWithResponses) ListUserGroupsWithResponse(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error) {
	rsp, err := c.ListUserGroups(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserGroupsResponse(rsp)
}

// AttachUserToGroupWithBodyWithResponse request with arbitrary body returning *AttachUserToGroupResponse
func (c *ClientWithResponses) AttachUserToGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error) {
	rsp, err := c.AttachUserToGroupWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToGroupWithResponse(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error) {
	rsp, err := c.AttachUserToGroup(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToGroupResponse(rsp)
}

// PermitUserGroupWithBodyWithResponse request with arbitrary body returning *PermitUserGroupResponse
func (c *ClientWithResponses) PermitUserGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error) {
	rsp, err := c.PermitUserGroupWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserGroupResponse(rsp)
}

func (c *ClientWithResponses) PermitUserGroupWithResponse(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error) {
	rsp, err := c.PermitUserGroup(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserGroupResponse(rsp)
}

// DeleteUserFromProjectWithBodyWithResponse request with arbitrary body returning *DeleteUserFromProjectResponse
func (c *ClientWithResponses) DeleteUserFromProjectWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromProjectResponse, error) {
	rsp, err := c.DeleteUserFromProjectWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromProjectResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromProjectWithResponse(ctx context.Context, userID UserID, body DeleteUserFromProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromProjectResponse, error) {
	rsp, err := c.DeleteUserFromProject(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromProjectResponse(rsp)
}

// ListUserProjectsWithResponse request returning *ListUserProjectsResponse
func (c *ClientWithResponses) ListUserProjectsWithResponse(ctx context.Context, userID UserID, params *ListUserProjectsParams, reqEditors ...RequestEditorFn) (*ListUserProjectsResponse, error) {
	rsp, err := c.ListUserProjects(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserProjectsResponse(rsp)
}

// AttachUserToProjectWithBodyWithResponse request with arbitrary body returning *AttachUserToProjectResponse
func (c *ClientWithResponses) AttachUserToProjectWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToProjectResponse, error) {
	rsp, err := c.AttachUserToProjectWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToProjectResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToProjectWithResponse(ctx context.Context, userID UserID, body AttachUserToProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToProjectResponse, error) {
	rsp, err := c.AttachUserToProject(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToProjectResponse(rsp)
}

// PermitUserProjectWithBodyWithResponse request with arbitrary body returning *PermitUserProjectResponse
func (c *ClientWithResponses) PermitUserProjectWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserProjectResponse, error) {
	rsp, err := c.PermitUserProjectWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserProjectResponse(rsp)
}

func (c *ClientWithResponses) PermitUserProjectWithResponse(ctx context.Context, userID UserID, body PermitUserProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserProjectResponse, error) {
	rsp, err := c.PermitUserProject(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserProjectResponse(rsp)
}

// ParseLoginAuthResponse parses an HTTP response from a LoginAuthWithResponse call
func ParseLoginAuthResponse(rsp *http.Response) (*LoginAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadCredentialsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProvidersResponse parses an HTTP response from a ListProvidersWithResponse call
func ParseListProvidersResponse(rsp *http.Response) (*ListProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProvidersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRedirectAuthResponse parses an HTTP response from a RedirectAuthWithResponse call
func ParseRedirectAuthResponse(rsp *http.Response) (*RedirectAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RedirectAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InvalidTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRefreshAuthResponse parses an HTTP response from a RefreshAuthWithResponse call
func ParseRefreshAuthResponse(rsp *http.Response) (*RefreshAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InvalidTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVerifyAuthResponse parses an HTTP response from a VerifyAuthWithResponse call
func ParseVerifyAuthResponse(rsp *http.Response) (*VerifyAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InvalidTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCallbackProviderResponse parses an HTTP response from a CallbackProviderWithResponse call
func ParseCallbackProviderResponse(rsp *http.Response) (*CallbackProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CallbackProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRequestProviderResponse parses an HTTP response from a RequestProviderWithResponse call
func ParseRequestProviderResponse(rsp *http.Response) (*RequestProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListGlobalEventsResponse parses an HTTP response from a ListGlobalEventsWithResponse call
func ParseListGlobalEventsResponse(rsp *http.Response) (*ListGlobalEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGlobalEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowGroupResponse parses an HTTP response from a ShowGroupWithResponse call
func ParseShowGroupResponse(rsp *http.Response) (*ShowGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupFromProjectResponse parses an HTTP response from a DeleteGroupFromProjectWithResponse call
func ParseDeleteGroupFromProjectResponse(rsp *http.Response) (*DeleteGroupFromProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupFromProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGroupProjectsResponse parses an HTTP response from a ListGroupProjectsWithResponse call
func ParseListGroupProjectsResponse(rsp *http.Response) (*ListGroupProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupProjectsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachGroupToProjectResponse parses an HTTP response from a AttachGroupToProjectWithResponse call
func ParseAttachGroupToProjectResponse(rsp *http.Response) (*AttachGroupToProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachGroupToProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitGroupProjectResponse parses an HTTP response from a PermitGroupProjectWithResponse call
func ParsePermitGroupProjectResponse(rsp *http.Response) (*PermitGroupProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitGroupProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupFromUserResponse parses an HTTP response from a DeleteGroupFromUserWithResponse call
func ParseDeleteGroupFromUserResponse(rsp *http.Response) (*DeleteGroupFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGroupUsersResponse parses an HTTP response from a ListGroupUsersWithResponse call
func ParseListGroupUsersResponse(rsp *http.Response) (*ListGroupUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachGroupToUserResponse parses an HTTP response from a AttachGroupToUserWithResponse call
func ParseAttachGroupToUserResponse(rsp *http.Response) (*AttachGroupToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachGroupToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitGroupUserResponse parses an HTTP response from a PermitGroupUserWithResponse call
func ParsePermitGroupUserResponse(rsp *http.Response) (*PermitGroupUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitGroupUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProfileResponse parses an HTTP response from a ShowProfileWithResponse call
func ParseShowProfileResponse(rsp *http.Response) (*ShowProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProfileResponse parses an HTTP response from a UpdateProfileWithResponse call
func ParseUpdateProfileResponse(rsp *http.Response) (*UpdateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTokenProfileResponse parses an HTTP response from a TokenProfileWithResponse call
func ParseTokenProfileResponse(rsp *http.Response) (*TokenProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectResponse parses an HTTP response from a ShowProjectWithResponse call
func ParseShowProjectResponse(rsp *http.Response) (*ShowProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectCredentialsResponse parses an HTTP response from a ListProjectCredentialsWithResponse call
func ParseListProjectCredentialsResponse(rsp *http.Response) (*ListProjectCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCredentialsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectCredentialResponse parses an HTTP response from a CreateProjectCredentialWithResponse call
func ParseCreateProjectCredentialResponse(rsp *http.Response) (*CreateProjectCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCredentialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectCredentialResponse parses an HTTP response from a DeleteProjectCredentialWithResponse call
func ParseDeleteProjectCredentialResponse(rsp *http.Response) (*DeleteProjectCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectCredentialResponse parses an HTTP response from a ShowProjectCredentialWithResponse call
func ParseShowProjectCredentialResponse(rsp *http.Response) (*ShowProjectCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCredentialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectCredentialResponse parses an HTTP response from a UpdateProjectCredentialWithResponse call
func ParseUpdateProjectCredentialResponse(rsp *http.Response) (*UpdateProjectCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCredentialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectEnvironmentsResponse parses an HTTP response from a ListProjectEnvironmentsWithResponse call
func ParseListProjectEnvironmentsResponse(rsp *http.Response) (*ListProjectEnvironmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectEnvironmentResponse parses an HTTP response from a CreateProjectEnvironmentWithResponse call
func ParseCreateProjectEnvironmentResponse(rsp *http.Response) (*CreateProjectEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectEnvironmentResponse parses an HTTP response from a DeleteProjectEnvironmentWithResponse call
func ParseDeleteProjectEnvironmentResponse(rsp *http.Response) (*DeleteProjectEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectEnvironmentResponse parses an HTTP response from a ShowProjectEnvironmentWithResponse call
func ParseShowProjectEnvironmentResponse(rsp *http.Response) (*ShowProjectEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectEnvironmentResponse parses an HTTP response from a UpdateProjectEnvironmentWithResponse call
func ParseUpdateProjectEnvironmentResponse(rsp *http.Response) (*UpdateProjectEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectEnvironmentSecretResponse parses an HTTP response from a CreateProjectEnvironmentSecretWithResponse call
func ParseCreateProjectEnvironmentSecretResponse(rsp *http.Response) (*CreateProjectEnvironmentSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectEnvironmentSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectEnvironmentSecretResponse parses an HTTP response from a DeleteProjectEnvironmentSecretWithResponse call
func ParseDeleteProjectEnvironmentSecretResponse(rsp *http.Response) (*DeleteProjectEnvironmentSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectEnvironmentSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectEnvironmentSecretResponse parses an HTTP response from a UpdateProjectEnvironmentSecretWithResponse call
func ParseUpdateProjectEnvironmentSecretResponse(rsp *http.Response) (*UpdateProjectEnvironmentSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectEnvironmentSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectEnvironmentValueResponse parses an HTTP response from a CreateProjectEnvironmentValueWithResponse call
func ParseCreateProjectEnvironmentValueResponse(rsp *http.Response) (*CreateProjectEnvironmentValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectEnvironmentValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentValueResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectEnvironmentValueResponse parses an HTTP response from a DeleteProjectEnvironmentValueWithResponse call
func ParseDeleteProjectEnvironmentValueResponse(rsp *http.Response) (*DeleteProjectEnvironmentValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectEnvironmentValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectEnvironmentValueResponse parses an HTTP response from a UpdateProjectEnvironmentValueWithResponse call
func ParseUpdateProjectEnvironmentValueResponse(rsp *http.Response) (*UpdateProjectEnvironmentValueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectEnvironmentValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEnvironmentValueResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectEventsResponse parses an HTTP response from a ListProjectEventsWithResponse call
func ParseListProjectEventsResponse(rsp *http.Response) (*ListProjectEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectExecutionsResponse parses an HTTP response from a ListProjectExecutionsWithResponse call
func ParseListProjectExecutionsResponse(rsp *http.Response) (*ListProjectExecutionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectExecutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectExecutionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectExecutionResponse parses an HTTP response from a CreateProjectExecutionWithResponse call
func ParseCreateProjectExecutionResponse(rsp *http.Response) (*CreateProjectExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectExecutionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectExecutionResponse parses an HTTP response from a DeleteProjectExecutionWithResponse call
func ParseDeleteProjectExecutionResponse(rsp *http.Response) (*DeleteProjectExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectExecutionResponse parses an HTTP response from a ShowProjectExecutionWithResponse call
func ParseShowProjectExecutionResponse(rsp *http.Response) (*ShowProjectExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectExecutionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseOutputProjectExecutionResponse parses an HTTP response from a OutputProjectExecutionWithResponse call
func ParseOutputProjectExecutionResponse(rsp *http.Response) (*OutputProjectExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OutputProjectExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectOutputResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePurgeProjectExecutionResponse parses an HTTP response from a PurgeProjectExecutionWithResponse call
func ParsePurgeProjectExecutionResponse(rsp *http.Response) (*PurgeProjectExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PurgeProjectExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectFromGroupResponse parses an HTTP response from a DeleteProjectFromGroupWithResponse call
func ParseDeleteProjectFromGroupResponse(rsp *http.Response) (*DeleteProjectFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectGroupsResponse parses an HTTP response from a ListProjectGroupsWithResponse call
func ParseListProjectGroupsResponse(rsp *http.Response) (*ListProjectGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachProjectToGroupResponse parses an HTTP response from a AttachProjectToGroupWithResponse call
func ParseAttachProjectToGroupResponse(rsp *http.Response) (*AttachProjectToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachProjectToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitProjectGroupResponse parses an HTTP response from a PermitProjectGroupWithResponse call
func ParsePermitProjectGroupResponse(rsp *http.Response) (*PermitProjectGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitProjectGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectInventoriesResponse parses an HTTP response from a ListProjectInventoriesWithResponse call
func ParseListProjectInventoriesResponse(rsp *http.Response) (*ListProjectInventoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectInventoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectInventoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectInventoryResponse parses an HTTP response from a CreateProjectInventoryWithResponse call
func ParseCreateProjectInventoryResponse(rsp *http.Response) (*CreateProjectInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectInventoryResponse parses an HTTP response from a DeleteProjectInventoryWithResponse call
func ParseDeleteProjectInventoryResponse(rsp *http.Response) (*DeleteProjectInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectInventoryResponse parses an HTTP response from a ShowProjectInventoryWithResponse call
func ParseShowProjectInventoryResponse(rsp *http.Response) (*ShowProjectInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectInventoryResponse parses an HTTP response from a UpdateProjectInventoryWithResponse call
func ParseUpdateProjectInventoryResponse(rsp *http.Response) (*UpdateProjectInventoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectInventoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectInventoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectRepositoriesResponse parses an HTTP response from a ListProjectRepositoriesWithResponse call
func ParseListProjectRepositoriesResponse(rsp *http.Response) (*ListProjectRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRepositoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectRepositoryResponse parses an HTTP response from a CreateProjectRepositoryWithResponse call
func ParseCreateProjectRepositoryResponse(rsp *http.Response) (*CreateProjectRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRepositoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectRepositoryResponse parses an HTTP response from a DeleteProjectRepositoryWithResponse call
func ParseDeleteProjectRepositoryResponse(rsp *http.Response) (*DeleteProjectRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectRepositoryResponse parses an HTTP response from a ShowProjectRepositoryWithResponse call
func ParseShowProjectRepositoryResponse(rsp *http.Response) (*ShowProjectRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRepositoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectRepositoryResponse parses an HTTP response from a UpdateProjectRepositoryWithResponse call
func ParseUpdateProjectRepositoryResponse(rsp *http.Response) (*UpdateProjectRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRepositoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectRunnersResponse parses an HTTP response from a ListProjectRunnersWithResponse call
func ParseListProjectRunnersResponse(rsp *http.Response) (*ListProjectRunnersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectRunnersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRunnersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectRunnerResponse parses an HTTP response from a CreateProjectRunnerWithResponse call
func ParseCreateProjectRunnerResponse(rsp *http.Response) (*CreateProjectRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRunnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectRunnerResponse parses an HTTP response from a DeleteProjectRunnerWithResponse call
func ParseDeleteProjectRunnerResponse(rsp *http.Response) (*DeleteProjectRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectRunnerResponse parses an HTTP response from a ShowProjectRunnerWithResponse call
func ParseShowProjectRunnerResponse(rsp *http.Response) (*ShowProjectRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRunnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectRunnerResponse parses an HTTP response from a UpdateProjectRunnerWithResponse call
func ParseUpdateProjectRunnerResponse(rsp *http.Response) (*UpdateProjectRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectRunnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectSchedulesResponse parses an HTTP response from a ListProjectSchedulesWithResponse call
func ParseListProjectSchedulesResponse(rsp *http.Response) (*ListProjectSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectSchedulesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectScheduleResponse parses an HTTP response from a CreateProjectScheduleWithResponse call
func ParseCreateProjectScheduleResponse(rsp *http.Response) (*CreateProjectScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectScheduleResponse parses an HTTP response from a DeleteProjectScheduleWithResponse call
func ParseDeleteProjectScheduleResponse(rsp *http.Response) (*DeleteProjectScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectScheduleResponse parses an HTTP response from a ShowProjectScheduleWithResponse call
func ParseShowProjectScheduleResponse(rsp *http.Response) (*ShowProjectScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectScheduleResponse parses an HTTP response from a UpdateProjectScheduleWithResponse call
func ParseUpdateProjectScheduleResponse(rsp *http.Response) (*UpdateProjectScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectTemplatesResponse parses an HTTP response from a ListProjectTemplatesWithResponse call
func ParseListProjectTemplatesResponse(rsp *http.Response) (*ListProjectTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectTemplateResponse parses an HTTP response from a CreateProjectTemplateWithResponse call
func ParseCreateProjectTemplateResponse(rsp *http.Response) (*CreateProjectTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectTemplateResponse parses an HTTP response from a DeleteProjectTemplateWithResponse call
func ParseDeleteProjectTemplateResponse(rsp *http.Response) (*DeleteProjectTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProjectTemplateResponse parses an HTTP response from a ShowProjectTemplateWithResponse call
func ParseShowProjectTemplateResponse(rsp *http.Response) (*ShowProjectTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProjectTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectTemplateResponse parses an HTTP response from a UpdateProjectTemplateWithResponse call
func ParseUpdateProjectTemplateResponse(rsp *http.Response) (*UpdateProjectTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectTemplateSurveyResponse parses an HTTP response from a CreateProjectTemplateSurveyWithResponse call
func ParseCreateProjectTemplateSurveyResponse(rsp *http.Response) (*CreateProjectTemplateSurveyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectTemplateSurveyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplateSurveyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectTemplateSurveyResponse parses an HTTP response from a DeleteProjectTemplateSurveyWithResponse call
func ParseDeleteProjectTemplateSurveyResponse(rsp *http.Response) (*DeleteProjectTemplateSurveyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectTemplateSurveyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectTemplateSurveyResponse parses an HTTP response from a UpdateProjectTemplateSurveyWithResponse call
func ParseUpdateProjectTemplateSurveyResponse(rsp *http.Response) (*UpdateProjectTemplateSurveyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectTemplateSurveyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplateSurveyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProjectTemplateVaultResponse parses an HTTP response from a CreateProjectTemplateVaultWithResponse call
func ParseCreateProjectTemplateVaultResponse(rsp *http.Response) (*CreateProjectTemplateVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectTemplateVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplateVaultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectTemplateVaultResponse parses an HTTP response from a DeleteProjectTemplateVaultWithResponse call
func ParseDeleteProjectTemplateVaultResponse(rsp *http.Response) (*DeleteProjectTemplateVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectTemplateVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProjectTemplateVaultResponse parses an HTTP response from a UpdateProjectTemplateVaultWithResponse call
func ParseUpdateProjectTemplateVaultResponse(rsp *http.Response) (*UpdateProjectTemplateVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectTemplateVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectTemplateVaultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProjectFromUserResponse parses an HTTP response from a DeleteProjectFromUserWithResponse call
func ParseDeleteProjectFromUserResponse(rsp *http.Response) (*DeleteProjectFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProjectUsersResponse parses an HTTP response from a ListProjectUsersWithResponse call
func ParseListProjectUsersResponse(rsp *http.Response) (*ListProjectUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachProjectToUserResponse parses an HTTP response from a AttachProjectToUserWithResponse call
func ParseAttachProjectToUserResponse(rsp *http.Response) (*AttachProjectToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachProjectToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitProjectUserResponse parses an HTTP response from a PermitProjectUserWithResponse call
func ParsePermitProjectUserResponse(rsp *http.Response) (*PermitProjectUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitProjectUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGlobalRunnersResponse parses an HTTP response from a ListGlobalRunnersWithResponse call
func ParseListGlobalRunnersResponse(rsp *http.Response) (*ListGlobalRunnersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGlobalRunnersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalRunnersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateGlobalRunnerResponse parses an HTTP response from a CreateGlobalRunnerWithResponse call
func ParseCreateGlobalRunnerResponse(rsp *http.Response) (*CreateGlobalRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGlobalRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalRunnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGlobalRunnerResponse parses an HTTP response from a DeleteGlobalRunnerWithResponse call
func ParseDeleteGlobalRunnerResponse(rsp *http.Response) (*DeleteGlobalRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGlobalRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowGlobalRunnerResponse parses an HTTP response from a ShowGlobalRunnerWithResponse call
func ParseShowGlobalRunnerResponse(rsp *http.Response) (*ShowGlobalRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowGlobalRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalRunnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGlobalRunnerResponse parses an HTTP response from a UpdateGlobalRunnerWithResponse call
func ParseUpdateGlobalRunnerResponse(rsp *http.Response) (*UpdateGlobalRunnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGlobalRunnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalRunnerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowUserResponse parses an HTTP response from a ShowUserWithResponse call
func ParseShowUserResponse(rsp *http.Response) (*ShowUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserFromGroupResponse parses an HTTP response from a DeleteUserFromGroupWithResponse call
func ParseDeleteUserFromGroupResponse(rsp *http.Response) (*DeleteUserFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUserGroupsResponse parses an HTTP response from a ListUserGroupsWithResponse call
func ParseListUserGroupsResponse(rsp *http.Response) (*ListUserGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachUserToGroupResponse parses an HTTP response from a AttachUserToGroupWithResponse call
func ParseAttachUserToGroupResponse(rsp *http.Response) (*AttachUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitUserGroupResponse parses an HTTP response from a PermitUserGroupWithResponse call
func ParsePermitUserGroupResponse(rsp *http.Response) (*PermitUserGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserFromProjectResponse parses an HTTP response from a DeleteUserFromProjectWithResponse call
func ParseDeleteUserFromProjectResponse(rsp *http.Response) (*DeleteUserFromProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUserProjectsResponse parses an HTTP response from a ListUserProjectsWithResponse call
func ParseListUserProjectsResponse(rsp *http.Response) (*ListUserProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserProjectsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachUserToProjectResponse parses an HTTP response from a AttachUserToProjectWithResponse call
func ParseAttachUserToProjectResponse(rsp *http.Response) (*AttachUserToProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitUserProjectResponse parses an HTTP response from a PermitUserProjectWithResponse call
func ParsePermitUserProjectResponse(rsp *http.Response) (*PermitUserProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Authenticate an user by credentials
	// (POST /auth/login)
	LoginAuth(w http.ResponseWriter, r *http.Request)
	// Fetch the available auth providers
	// (GET /auth/providers)
	ListProviders(w http.ResponseWriter, r *http.Request)
	// Retrieve real token after redirect
	// (POST /auth/redirect)
	RedirectAuth(w http.ResponseWriter, r *http.Request)
	// Refresh an auth token before it expires
	// (GET /auth/refresh)
	RefreshAuth(w http.ResponseWriter, r *http.Request)
	// Verify validity for an authentication token
	// (GET /auth/verify)
	VerifyAuth(w http.ResponseWriter, r *http.Request)
	// Callback to parse the defined provider
	// (GET /auth/{provider}/callback)
	CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams)
	// Request the redirect to defined provider
	// (GET /auth/{provider}/request)
	RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam)
	// Fetch all events
	// (GET /events)
	ListGlobalEvents(w http.ResponseWriter, r *http.Request, params ListGlobalEventsParams)
	// Fetch all available groups
	// (GET /groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// Create a new group
	// (POST /groups)
	CreateGroup(w http.ResponseWriter, r *http.Request)
	// Delete a specific group
	// (DELETE /groups/{group_id})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch a specific group
	// (GET /groups/{group_id})
	ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update a specific group
	// (PUT /groups/{group_id})
	UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a project from group
	// (DELETE /groups/{group_id}/projects)
	DeleteGroupFromProject(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all projects attached to group
	// (GET /groups/{group_id}/projects)
	ListGroupProjects(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupProjectsParams)
	// Attach a project to group
	// (POST /groups/{group_id}/projects)
	AttachGroupToProject(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update project perms for group
	// (PUT /groups/{group_id}/projects)
	PermitGroupProject(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Unlink a user from group
	// (DELETE /groups/{group_id}/users)
	DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch all users attached to group
	// (GET /groups/{group_id}/users)
	ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams)
	// Attach a user to group
	// (POST /groups/{group_id}/users)
	AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Update user perms for group
	// (PUT /groups/{group_id}/users)
	PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID)
	// Fetch profile details of the personal account
	// (GET /profile/self)
	ShowProfile(w http.ResponseWriter, r *http.Request)
	// Update your own profile information
	// (PUT /profile/self)
	UpdateProfile(w http.ResponseWriter, r *http.Request)
	// Retrieve an unlimited auth token
	// (GET /profile/token)
	TokenProfile(w http.ResponseWriter, r *http.Request)
	// Fetch all available projects
	// (GET /projects)
	ListProjects(w http.ResponseWriter, r *http.Request, params ListProjectsParams)
	// Create a new project
	// (POST /projects)
	CreateProject(w http.ResponseWriter, r *http.Request)
	// Delete a specific project
	// (DELETE /projects/{project_id})
	DeleteProject(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Fetch a specific project
	// (GET /projects/{project_id})
	ShowProject(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Update a specific project
	// (PUT /projects/{project_id})
	UpdateProject(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Fetch all credentials for a project
	// (GET /projects/{project_id}/credentials)
	ListProjectCredentials(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectCredentialsParams)
	// Create a new credential
	// (POST /projects/{project_id}/credentials)
	CreateProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific credential for a project
	// (DELETE /projects/{project_id}/credentials/{credential_id})
	DeleteProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID, credentialID CredentialID)
	// Fetch a specific credential for a project
	// (GET /projects/{project_id}/credentials/{credential_id})
	ShowProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID, credentialID CredentialID)
	// Update a specific credential for a project
	// (PUT /projects/{project_id}/credentials/{credential_id})
	UpdateProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID, credentialID CredentialID)
	// Fetch all environments for a project
	// (GET /projects/{project_id}/environments)
	ListProjectEnvironments(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectEnvironmentsParams)
	// Create a new environment
	// (POST /projects/{project_id}/environments)
	CreateProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific environment for a project
	// (DELETE /projects/{project_id}/environments/{environment_id})
	DeleteProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID)
	// Fetch a specific environment for a project
	// (GET /projects/{project_id}/environments/{environment_id})
	ShowProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID)
	// Update a specific environment for a project
	// (PUT /projects/{project_id}/environments/{environment_id})
	UpdateProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID)
	// Create a new secret on an environment
	// (POST /projects/{project_id}/environments/{environment_id}/secrets)
	CreateProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID)
	// Delete a secret on an environment for a project
	// (DELETE /projects/{project_id}/environments/{environment_id}/secrets/{secret_id})
	DeleteProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, secretID SecretID)
	// Update a secret on an environment for a project
	// (PUT /projects/{project_id}/environments/{environment_id}/secrets/{secret_id})
	UpdateProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, secretID SecretID)
	// Create a new value on an environment
	// (POST /projects/{project_id}/environments/{environment_id}/values)
	CreateProjectEnvironmentValue(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID)
	// Delete a value on an environment for a project
	// (DELETE /projects/{project_id}/environments/{environment_id}/values/{value_id})
	DeleteProjectEnvironmentValue(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, valueID ValueID)
	// Update a value on an environment for a project
	// (PUT /projects/{project_id}/environments/{environment_id}/values/{value_id})
	UpdateProjectEnvironmentValue(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, valueID ValueID)
	// Fetch all events for a project
	// (GET /projects/{project_id}/events)
	ListProjectEvents(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectEventsParams)
	// Fetch all executions for a project
	// (GET /projects/{project_id}/executions)
	ListProjectExecutions(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectExecutionsParams)
	// Create a new execution
	// (POST /projects/{project_id}/executions)
	CreateProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific execution for a project
	// (DELETE /projects/{project_id}/executions/{execution_id})
	DeleteProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID)
	// Fetch a specific execution for a project
	// (GET /projects/{project_id}/executions/{execution_id})
	ShowProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID)
	// Output a specific execution for a project
	// (GET /projects/{project_id}/executions/{execution_id}/output)
	OutputProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID)
	// Purge a specific execution for a project
	// (GET /projects/{project_id}/executions/{execution_id}/purge)
	PurgeProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID)
	// Unlink a group from project
	// (DELETE /projects/{project_id}/groups)
	DeleteProjectFromGroup(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Fetch all groups attached to project
	// (GET /projects/{project_id}/groups)
	ListProjectGroups(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectGroupsParams)
	// Attach a group to project
	// (POST /projects/{project_id}/groups)
	AttachProjectToGroup(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Update group perms for project
	// (PUT /projects/{project_id}/groups)
	PermitProjectGroup(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Fetch all inventories for a project
	// (GET /projects/{project_id}/inventories)
	ListProjectInventories(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectInventoriesParams)
	// Create a new inventory
	// (POST /projects/{project_id}/inventories)
	CreateProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific inventory for a project
	// (DELETE /projects/{project_id}/inventories/{inventory_id})
	DeleteProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID, inventoryID InventoryID)
	// Fetch a specific inventory for a project
	// (GET /projects/{project_id}/inventories/{inventory_id})
	ShowProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID, inventoryID InventoryID)
	// Update a specific inventory for a project
	// (PUT /projects/{project_id}/inventories/{inventory_id})
	UpdateProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID, inventoryID InventoryID)
	// Fetch all repositories for a project
	// (GET /projects/{project_id}/repositories)
	ListProjectRepositories(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectRepositoriesParams)
	// Create a new repository
	// (POST /projects/{project_id}/repositories)
	CreateProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific repository for a project
	// (DELETE /projects/{project_id}/repositories/{repository_id})
	DeleteProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID, repositoryID RepositoryID)
	// Fetch a specific repository for a project
	// (GET /projects/{project_id}/repositories/{repository_id})
	ShowProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID, repositoryID RepositoryID)
	// Update a specific repository for a project
	// (PUT /projects/{project_id}/repositories/{repository_id})
	UpdateProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID, repositoryID RepositoryID)
	// Fetch all runners for a project
	// (GET /projects/{project_id}/runners)
	ListProjectRunners(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectRunnersParams)
	// Create a new runner
	// (POST /projects/{project_id}/runners)
	CreateProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific runner for a project
	// (DELETE /projects/{project_id}/runners/{runner_id})
	DeleteProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID, runnerID RunnerID)
	// Fetch a specific runner for a project
	// (GET /projects/{project_id}/runners/{runner_id})
	ShowProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID, runnerID RunnerID)
	// Update a specific runner for a project
	// (PUT /projects/{project_id}/runners/{runner_id})
	UpdateProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID, runnerID RunnerID)
	// Fetch all schedules for a project
	// (GET /projects/{project_id}/schedules)
	ListProjectSchedules(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectSchedulesParams)
	// Create a new schedule
	// (POST /projects/{project_id}/schedules)
	CreateProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific schedule for a project
	// (DELETE /projects/{project_id}/schedules/{schedule_id})
	DeleteProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID, scheduleID ScheduleID)
	// Fetch a specific schedule for a project
	// (GET /projects/{project_id}/schedules/{schedule_id})
	ShowProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID, scheduleID ScheduleID)
	// Update a specific schedule for a project
	// (PUT /projects/{project_id}/schedules/{schedule_id})
	UpdateProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID, scheduleID ScheduleID)
	// Fetch all templates for a project
	// (GET /projects/{project_id}/templates)
	ListProjectTemplates(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectTemplatesParams)
	// Create a new template
	// (POST /projects/{project_id}/templates)
	CreateProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Delete a specific template for a project
	// (DELETE /projects/{project_id}/templates/{template_id})
	DeleteProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID)
	// Fetch a specific template for a project
	// (GET /projects/{project_id}/templates/{template_id})
	ShowProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID)
	// Update a specific template for a project
	// (PUT /projects/{project_id}/templates/{template_id})
	UpdateProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID)
	// Create a new survey on a template
	// (POST /projects/{project_id}/templates/{template_id}/surveys)
	CreateProjectTemplateSurvey(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID)
	// Delete a survey on a template for a project
	// (DELETE /projects/{project_id}/templates/{template_id}/surveys/{survey_id})
	DeleteProjectTemplateSurvey(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, surveyID SurveyID)
	// Update a survey on a template for a project
	// (PUT /projects/{project_id}/templates/{template_id}/surveys/{survey_id})
	UpdateProjectTemplateSurvey(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, surveyID SurveyID)
	// Create a new vault on a template
	// (POST /projects/{project_id}/templates/{template_id}/vaults)
	CreateProjectTemplateVault(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID)
	// Delete a vault on a template for a project
	// (DELETE /projects/{project_id}/templates/{template_id}/vaults/{vault_id})
	DeleteProjectTemplateVault(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, vaultID VaultID)
	// Update a vault on a template for a project
	// (PUT /projects/{project_id}/templates/{template_id}/vaults/{vault_id})
	UpdateProjectTemplateVault(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, vaultID VaultID)
	// Unlink a user from project
	// (DELETE /projects/{project_id}/users)
	DeleteProjectFromUser(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Fetch all users attached to project
	// (GET /projects/{project_id}/users)
	ListProjectUsers(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectUsersParams)
	// Attach a user to project
	// (POST /projects/{project_id}/users)
	AttachProjectToUser(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Update user perms for project
	// (PUT /projects/{project_id}/users)
	PermitProjectUser(w http.ResponseWriter, r *http.Request, projectID ProjectID)
	// Fetch all runners
	// (GET /runners)
	ListGlobalRunners(w http.ResponseWriter, r *http.Request, params ListGlobalRunnersParams)
	// Create a new global runner
	// (POST /runners)
	CreateGlobalRunner(w http.ResponseWriter, r *http.Request)
	// Delete a specific runner
	// (DELETE /runners/{runner_id})
	DeleteGlobalRunner(w http.ResponseWriter, r *http.Request, runnerID RunnerID)
	// Fetch a specific runner
	// (GET /runners/{runner_id})
	ShowGlobalRunner(w http.ResponseWriter, r *http.Request, runnerID RunnerID)
	// Update a specific runner
	// (PUT /runners/{runner_id})
	UpdateGlobalRunner(w http.ResponseWriter, r *http.Request, runnerID RunnerID)
	// Fetch all available users
	// (GET /users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// Create a new user
	// (POST /users)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Delete a specific user
	// (DELETE /users/{user_id})
	DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch a specific user
	// (GET /users/{user_id})
	ShowUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update a specific user
	// (PUT /users/{user_id})
	UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a group from user
	// (DELETE /users/{user_id}/groups)
	DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all groups attached to user
	// (GET /users/{user_id}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams)
	// Attach a group to user
	// (POST /users/{user_id}/groups)
	AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update group perms for user
	// (PUT /users/{user_id}/groups)
	PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID)
	// Unlink a project from user
	// (DELETE /users/{user_id}/projects)
	DeleteUserFromProject(w http.ResponseWriter, r *http.Request, userID UserID)
	// Fetch all projects attached to user
	// (GET /users/{user_id}/projects)
	ListUserProjects(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserProjectsParams)
	// Attach a project to user
	// (POST /users/{user_id}/projects)
	AttachUserToProject(w http.ResponseWriter, r *http.Request, userID UserID)
	// Update project perms for user
	// (PUT /users/{user_id}/projects)
	PermitUserProject(w http.ResponseWriter, r *http.Request, userID UserID)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Authenticate an user by credentials
// (POST /auth/login)
func (_ Unimplemented) LoginAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch the available auth providers
// (GET /auth/providers)
func (_ Unimplemented) ListProviders(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve real token after redirect
// (POST /auth/redirect)
func (_ Unimplemented) RedirectAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Refresh an auth token before it expires
// (GET /auth/refresh)
func (_ Unimplemented) RefreshAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Verify validity for an authentication token
// (GET /auth/verify)
func (_ Unimplemented) VerifyAuth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Callback to parse the defined provider
// (GET /auth/{provider}/callback)
func (_ Unimplemented) CallbackProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam, params CallbackProviderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Request the redirect to defined provider
// (GET /auth/{provider}/request)
func (_ Unimplemented) RequestProvider(w http.ResponseWriter, r *http.Request, provider AuthProviderParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all events
// (GET /events)
func (_ Unimplemented) ListGlobalEvents(w http.ResponseWriter, r *http.Request, params ListGlobalEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available groups
// (GET /groups)
func (_ Unimplemented) ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new group
// (POST /groups)
func (_ Unimplemented) CreateGroup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific group
// (DELETE /groups/{group_id})
func (_ Unimplemented) DeleteGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific group
// (GET /groups/{group_id})
func (_ Unimplemented) ShowGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific group
// (PUT /groups/{group_id})
func (_ Unimplemented) UpdateGroup(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a project from group
// (DELETE /groups/{group_id}/projects)
func (_ Unimplemented) DeleteGroupFromProject(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all projects attached to group
// (GET /groups/{group_id}/projects)
func (_ Unimplemented) ListGroupProjects(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupProjectsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a project to group
// (POST /groups/{group_id}/projects)
func (_ Unimplemented) AttachGroupToProject(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update project perms for group
// (PUT /groups/{group_id}/projects)
func (_ Unimplemented) PermitGroupProject(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from group
// (DELETE /groups/{group_id}/users)
func (_ Unimplemented) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to group
// (GET /groups/{group_id}/users)
func (_ Unimplemented) ListGroupUsers(w http.ResponseWriter, r *http.Request, groupID GroupID, params ListGroupUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to group
// (POST /groups/{group_id}/users)
func (_ Unimplemented) AttachGroupToUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for group
// (PUT /groups/{group_id}/users)
func (_ Unimplemented) PermitGroupUser(w http.ResponseWriter, r *http.Request, groupID GroupID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch profile details of the personal account
// (GET /profile/self)
func (_ Unimplemented) ShowProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update your own profile information
// (PUT /profile/self)
func (_ Unimplemented) UpdateProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Retrieve an unlimited auth token
// (GET /profile/token)
func (_ Unimplemented) TokenProfile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available projects
// (GET /projects)
func (_ Unimplemented) ListProjects(w http.ResponseWriter, r *http.Request, params ListProjectsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new project
// (POST /projects)
func (_ Unimplemented) CreateProject(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific project
// (DELETE /projects/{project_id})
func (_ Unimplemented) DeleteProject(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific project
// (GET /projects/{project_id})
func (_ Unimplemented) ShowProject(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific project
// (PUT /projects/{project_id})
func (_ Unimplemented) UpdateProject(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all credentials for a project
// (GET /projects/{project_id}/credentials)
func (_ Unimplemented) ListProjectCredentials(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectCredentialsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new credential
// (POST /projects/{project_id}/credentials)
func (_ Unimplemented) CreateProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific credential for a project
// (DELETE /projects/{project_id}/credentials/{credential_id})
func (_ Unimplemented) DeleteProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID, credentialID CredentialID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific credential for a project
// (GET /projects/{project_id}/credentials/{credential_id})
func (_ Unimplemented) ShowProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID, credentialID CredentialID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific credential for a project
// (PUT /projects/{project_id}/credentials/{credential_id})
func (_ Unimplemented) UpdateProjectCredential(w http.ResponseWriter, r *http.Request, projectID ProjectID, credentialID CredentialID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all environments for a project
// (GET /projects/{project_id}/environments)
func (_ Unimplemented) ListProjectEnvironments(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectEnvironmentsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new environment
// (POST /projects/{project_id}/environments)
func (_ Unimplemented) CreateProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific environment for a project
// (DELETE /projects/{project_id}/environments/{environment_id})
func (_ Unimplemented) DeleteProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific environment for a project
// (GET /projects/{project_id}/environments/{environment_id})
func (_ Unimplemented) ShowProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific environment for a project
// (PUT /projects/{project_id}/environments/{environment_id})
func (_ Unimplemented) UpdateProjectEnvironment(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new secret on an environment
// (POST /projects/{project_id}/environments/{environment_id}/secrets)
func (_ Unimplemented) CreateProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a secret on an environment for a project
// (DELETE /projects/{project_id}/environments/{environment_id}/secrets/{secret_id})
func (_ Unimplemented) DeleteProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, secretID SecretID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a secret on an environment for a project
// (PUT /projects/{project_id}/environments/{environment_id}/secrets/{secret_id})
func (_ Unimplemented) UpdateProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, secretID SecretID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new value on an environment
// (POST /projects/{project_id}/environments/{environment_id}/values)
func (_ Unimplemented) CreateProjectEnvironmentValue(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a value on an environment for a project
// (DELETE /projects/{project_id}/environments/{environment_id}/values/{value_id})
func (_ Unimplemented) DeleteProjectEnvironmentValue(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, valueID ValueID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a value on an environment for a project
// (PUT /projects/{project_id}/environments/{environment_id}/values/{value_id})
func (_ Unimplemented) UpdateProjectEnvironmentValue(w http.ResponseWriter, r *http.Request, projectID ProjectID, environmentID EnvironmentID, valueID ValueID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all events for a project
// (GET /projects/{project_id}/events)
func (_ Unimplemented) ListProjectEvents(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectEventsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all executions for a project
// (GET /projects/{project_id}/executions)
func (_ Unimplemented) ListProjectExecutions(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectExecutionsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new execution
// (POST /projects/{project_id}/executions)
func (_ Unimplemented) CreateProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific execution for a project
// (DELETE /projects/{project_id}/executions/{execution_id})
func (_ Unimplemented) DeleteProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific execution for a project
// (GET /projects/{project_id}/executions/{execution_id})
func (_ Unimplemented) ShowProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Output a specific execution for a project
// (GET /projects/{project_id}/executions/{execution_id}/output)
func (_ Unimplemented) OutputProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Purge a specific execution for a project
// (GET /projects/{project_id}/executions/{execution_id}/purge)
func (_ Unimplemented) PurgeProjectExecution(w http.ResponseWriter, r *http.Request, projectID ProjectID, executionID ExecutionID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from project
// (DELETE /projects/{project_id}/groups)
func (_ Unimplemented) DeleteProjectFromGroup(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to project
// (GET /projects/{project_id}/groups)
func (_ Unimplemented) ListProjectGroups(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to project
// (POST /projects/{project_id}/groups)
func (_ Unimplemented) AttachProjectToGroup(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for project
// (PUT /projects/{project_id}/groups)
func (_ Unimplemented) PermitProjectGroup(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all inventories for a project
// (GET /projects/{project_id}/inventories)
func (_ Unimplemented) ListProjectInventories(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectInventoriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new inventory
// (POST /projects/{project_id}/inventories)
func (_ Unimplemented) CreateProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific inventory for a project
// (DELETE /projects/{project_id}/inventories/{inventory_id})
func (_ Unimplemented) DeleteProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID, inventoryID InventoryID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific inventory for a project
// (GET /projects/{project_id}/inventories/{inventory_id})
func (_ Unimplemented) ShowProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID, inventoryID InventoryID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific inventory for a project
// (PUT /projects/{project_id}/inventories/{inventory_id})
func (_ Unimplemented) UpdateProjectInventory(w http.ResponseWriter, r *http.Request, projectID ProjectID, inventoryID InventoryID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all repositories for a project
// (GET /projects/{project_id}/repositories)
func (_ Unimplemented) ListProjectRepositories(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectRepositoriesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new repository
// (POST /projects/{project_id}/repositories)
func (_ Unimplemented) CreateProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific repository for a project
// (DELETE /projects/{project_id}/repositories/{repository_id})
func (_ Unimplemented) DeleteProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID, repositoryID RepositoryID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific repository for a project
// (GET /projects/{project_id}/repositories/{repository_id})
func (_ Unimplemented) ShowProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID, repositoryID RepositoryID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific repository for a project
// (PUT /projects/{project_id}/repositories/{repository_id})
func (_ Unimplemented) UpdateProjectRepository(w http.ResponseWriter, r *http.Request, projectID ProjectID, repositoryID RepositoryID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all runners for a project
// (GET /projects/{project_id}/runners)
func (_ Unimplemented) ListProjectRunners(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectRunnersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new runner
// (POST /projects/{project_id}/runners)
func (_ Unimplemented) CreateProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific runner for a project
// (DELETE /projects/{project_id}/runners/{runner_id})
func (_ Unimplemented) DeleteProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID, runnerID RunnerID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific runner for a project
// (GET /projects/{project_id}/runners/{runner_id})
func (_ Unimplemented) ShowProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID, runnerID RunnerID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific runner for a project
// (PUT /projects/{project_id}/runners/{runner_id})
func (_ Unimplemented) UpdateProjectRunner(w http.ResponseWriter, r *http.Request, projectID ProjectID, runnerID RunnerID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all schedules for a project
// (GET /projects/{project_id}/schedules)
func (_ Unimplemented) ListProjectSchedules(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectSchedulesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new schedule
// (POST /projects/{project_id}/schedules)
func (_ Unimplemented) CreateProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific schedule for a project
// (DELETE /projects/{project_id}/schedules/{schedule_id})
func (_ Unimplemented) DeleteProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID, scheduleID ScheduleID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific schedule for a project
// (GET /projects/{project_id}/schedules/{schedule_id})
func (_ Unimplemented) ShowProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID, scheduleID ScheduleID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific schedule for a project
// (PUT /projects/{project_id}/schedules/{schedule_id})
func (_ Unimplemented) UpdateProjectSchedule(w http.ResponseWriter, r *http.Request, projectID ProjectID, scheduleID ScheduleID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all templates for a project
// (GET /projects/{project_id}/templates)
func (_ Unimplemented) ListProjectTemplates(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectTemplatesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new template
// (POST /projects/{project_id}/templates)
func (_ Unimplemented) CreateProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific template for a project
// (DELETE /projects/{project_id}/templates/{template_id})
func (_ Unimplemented) DeleteProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific template for a project
// (GET /projects/{project_id}/templates/{template_id})
func (_ Unimplemented) ShowProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific template for a project
// (PUT /projects/{project_id}/templates/{template_id})
func (_ Unimplemented) UpdateProjectTemplate(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new survey on a template
// (POST /projects/{project_id}/templates/{template_id}/surveys)
func (_ Unimplemented) CreateProjectTemplateSurvey(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a survey on a template for a project
// (DELETE /projects/{project_id}/templates/{template_id}/surveys/{survey_id})
func (_ Unimplemented) DeleteProjectTemplateSurvey(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, surveyID SurveyID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a survey on a template for a project
// (PUT /projects/{project_id}/templates/{template_id}/surveys/{survey_id})
func (_ Unimplemented) UpdateProjectTemplateSurvey(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, surveyID SurveyID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new vault on a template
// (POST /projects/{project_id}/templates/{template_id}/vaults)
func (_ Unimplemented) CreateProjectTemplateVault(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a vault on a template for a project
// (DELETE /projects/{project_id}/templates/{template_id}/vaults/{vault_id})
func (_ Unimplemented) DeleteProjectTemplateVault(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, vaultID VaultID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a vault on a template for a project
// (PUT /projects/{project_id}/templates/{template_id}/vaults/{vault_id})
func (_ Unimplemented) UpdateProjectTemplateVault(w http.ResponseWriter, r *http.Request, projectID ProjectID, templateID TemplateID, vaultID VaultID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a user from project
// (DELETE /projects/{project_id}/users)
func (_ Unimplemented) DeleteProjectFromUser(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all users attached to project
// (GET /projects/{project_id}/users)
func (_ Unimplemented) ListProjectUsers(w http.ResponseWriter, r *http.Request, projectID ProjectID, params ListProjectUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a user to project
// (POST /projects/{project_id}/users)
func (_ Unimplemented) AttachProjectToUser(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update user perms for project
// (PUT /projects/{project_id}/users)
func (_ Unimplemented) PermitProjectUser(w http.ResponseWriter, r *http.Request, projectID ProjectID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all runners
// (GET /runners)
func (_ Unimplemented) ListGlobalRunners(w http.ResponseWriter, r *http.Request, params ListGlobalRunnersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new global runner
// (POST /runners)
func (_ Unimplemented) CreateGlobalRunner(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific runner
// (DELETE /runners/{runner_id})
func (_ Unimplemented) DeleteGlobalRunner(w http.ResponseWriter, r *http.Request, runnerID RunnerID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific runner
// (GET /runners/{runner_id})
func (_ Unimplemented) ShowGlobalRunner(w http.ResponseWriter, r *http.Request, runnerID RunnerID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific runner
// (PUT /runners/{runner_id})
func (_ Unimplemented) UpdateGlobalRunner(w http.ResponseWriter, r *http.Request, runnerID RunnerID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all available users
// (GET /users)
func (_ Unimplemented) ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new user
// (POST /users)
func (_ Unimplemented) CreateUser(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a specific user
// (DELETE /users/{user_id})
func (_ Unimplemented) DeleteUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch a specific user
// (GET /users/{user_id})
func (_ Unimplemented) ShowUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a specific user
// (PUT /users/{user_id})
func (_ Unimplemented) UpdateUser(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a group from user
// (DELETE /users/{user_id}/groups)
func (_ Unimplemented) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all groups attached to user
// (GET /users/{user_id}/groups)
func (_ Unimplemented) ListUserGroups(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserGroupsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a group to user
// (POST /users/{user_id}/groups)
func (_ Unimplemented) AttachUserToGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update group perms for user
// (PUT /users/{user_id}/groups)
func (_ Unimplemented) PermitUserGroup(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Unlink a project from user
// (DELETE /users/{user_id}/projects)
func (_ Unimplemented) DeleteUserFromProject(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fetch all projects attached to user
// (GET /users/{user_id}/projects)
func (_ Unimplemented) ListUserProjects(w http.ResponseWriter, r *http.Request, userID UserID, params ListUserProjectsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Attach a project to user
// (POST /users/{user_id}/projects)
func (_ Unimplemented) AttachUserToProject(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update project perms for user
// (PUT /users/{user_id}/projects)
func (_ Unimplemented) PermitUserProject(w http.ResponseWriter, r *http.Request, userID UserID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// LoginAuth operation middleware
func (siw *ServerInterfaceWrapper) LoginAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LoginAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProviders operation middleware
func (siw *ServerInterfaceWrapper) ListProviders(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProviders(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RedirectAuth operation middleware
func (siw *ServerInterfaceWrapper) RedirectAuth(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RedirectAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RefreshAuth operation middleware
func (siw *ServerInterfaceWrapper) RefreshAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RefreshAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// VerifyAuth operation middleware
func (siw *ServerInterfaceWrapper) VerifyAuth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.VerifyAuth(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CallbackProvider operation middleware
func (siw *ServerInterfaceWrapper) CallbackProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CallbackProviderParams

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, false, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CallbackProvider(w, r, provider, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// RequestProvider operation middleware
func (siw *ServerInterfaceWrapper) RequestProvider(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "provider" -------------
	var provider AuthProviderParam

	err = runtime.BindStyledParameterWithOptions("simple", "provider", chi.URLParam(r, "provider"), &provider, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "provider", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestProvider(w, r, provider)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGlobalEvents operation middleware
func (siw *ServerInterfaceWrapper) ListGlobalEvents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGlobalEventsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGlobalEvents(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowGroup operation middleware
func (siw *ServerInterfaceWrapper) ShowGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGroup operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroup(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromProject operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromProject(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupProjects operation middleware
func (siw *ServerInterfaceWrapper) ListGroupProjects(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupProjectsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupProjects(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToProject operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToProject(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupProject operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupProject(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGroupFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupFromUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGroupUsers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupUsers(w, r, groupID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachGroupToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachGroupToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachGroupToUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitGroupUser operation middleware
func (siw *ServerInterfaceWrapper) PermitGroupUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "group_id" -------------
	var groupID GroupID

	err = runtime.BindStyledParameterWithOptions("simple", "group_id", chi.URLParam(r, "group_id"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitGroupUser(w, r, groupID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProfile operation middleware
func (siw *ServerInterfaceWrapper) ShowProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProfile operation middleware
func (siw *ServerInterfaceWrapper) UpdateProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// TokenProfile operation middleware
func (siw *ServerInterfaceWrapper) TokenProfile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TokenProfile(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjects operation middleware
func (siw *ServerInterfaceWrapper) ListProjects(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjects(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProject operation middleware
func (siw *ServerInterfaceWrapper) CreateProject(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProject(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProject operation middleware
func (siw *ServerInterfaceWrapper) DeleteProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProject(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProject operation middleware
func (siw *ServerInterfaceWrapper) ShowProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProject(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProject operation middleware
func (siw *ServerInterfaceWrapper) UpdateProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProject(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectCredentials operation middleware
func (siw *ServerInterfaceWrapper) ListProjectCredentials(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectCredentialsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectCredentials(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectCredential operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectCredential(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectCredential(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectCredential operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectCredential(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "credential_id" -------------
	var credentialID CredentialID

	err = runtime.BindStyledParameterWithOptions("simple", "credential_id", chi.URLParam(r, "credential_id"), &credentialID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "credential_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectCredential(w, r, projectID, credentialID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectCredential operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectCredential(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "credential_id" -------------
	var credentialID CredentialID

	err = runtime.BindStyledParameterWithOptions("simple", "credential_id", chi.URLParam(r, "credential_id"), &credentialID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "credential_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectCredential(w, r, projectID, credentialID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectCredential operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectCredential(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "credential_id" -------------
	var credentialID CredentialID

	err = runtime.BindStyledParameterWithOptions("simple", "credential_id", chi.URLParam(r, "credential_id"), &credentialID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "credential_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectCredential(w, r, projectID, credentialID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectEnvironments operation middleware
func (siw *ServerInterfaceWrapper) ListProjectEnvironments(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectEnvironmentsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectEnvironments(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectEnvironment operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectEnvironment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectEnvironment(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectEnvironment operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectEnvironment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectEnvironment(w, r, projectID, environmentID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectEnvironment operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectEnvironment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectEnvironment(w, r, projectID, environmentID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectEnvironment operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectEnvironment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectEnvironment(w, r, projectID, environmentID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectEnvironmentSecret operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectEnvironmentSecret(w, r, projectID, environmentID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectEnvironmentSecret operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	// ------------- Path parameter "secret_id" -------------
	var secretID SecretID

	err = runtime.BindStyledParameterWithOptions("simple", "secret_id", chi.URLParam(r, "secret_id"), &secretID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "secret_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectEnvironmentSecret(w, r, projectID, environmentID, secretID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectEnvironmentSecret operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectEnvironmentSecret(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	// ------------- Path parameter "secret_id" -------------
	var secretID SecretID

	err = runtime.BindStyledParameterWithOptions("simple", "secret_id", chi.URLParam(r, "secret_id"), &secretID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "secret_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectEnvironmentSecret(w, r, projectID, environmentID, secretID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectEnvironmentValue operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectEnvironmentValue(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectEnvironmentValue(w, r, projectID, environmentID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectEnvironmentValue operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectEnvironmentValue(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	// ------------- Path parameter "value_id" -------------
	var valueID ValueID

	err = runtime.BindStyledParameterWithOptions("simple", "value_id", chi.URLParam(r, "value_id"), &valueID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "value_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectEnvironmentValue(w, r, projectID, environmentID, valueID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectEnvironmentValue operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectEnvironmentValue(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "environment_id" -------------
	var environmentID EnvironmentID

	err = runtime.BindStyledParameterWithOptions("simple", "environment_id", chi.URLParam(r, "environment_id"), &environmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "environment_id", Err: err})
		return
	}

	// ------------- Path parameter "value_id" -------------
	var valueID ValueID

	err = runtime.BindStyledParameterWithOptions("simple", "value_id", chi.URLParam(r, "value_id"), &valueID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "value_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectEnvironmentValue(w, r, projectID, environmentID, valueID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectEvents operation middleware
func (siw *ServerInterfaceWrapper) ListProjectEvents(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectEventsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectEvents(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectExecutions operation middleware
func (siw *ServerInterfaceWrapper) ListProjectExecutions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectExecutionsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectExecutions(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectExecution operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectExecution(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectExecution(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectExecution operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectExecution(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "execution_id" -------------
	var executionID ExecutionID

	err = runtime.BindStyledParameterWithOptions("simple", "execution_id", chi.URLParam(r, "execution_id"), &executionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "execution_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectExecution(w, r, projectID, executionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectExecution operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectExecution(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "execution_id" -------------
	var executionID ExecutionID

	err = runtime.BindStyledParameterWithOptions("simple", "execution_id", chi.URLParam(r, "execution_id"), &executionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "execution_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectExecution(w, r, projectID, executionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// OutputProjectExecution operation middleware
func (siw *ServerInterfaceWrapper) OutputProjectExecution(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "execution_id" -------------
	var executionID ExecutionID

	err = runtime.BindStyledParameterWithOptions("simple", "execution_id", chi.URLParam(r, "execution_id"), &executionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "execution_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OutputProjectExecution(w, r, projectID, executionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PurgeProjectExecution operation middleware
func (siw *ServerInterfaceWrapper) PurgeProjectExecution(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "execution_id" -------------
	var executionID ExecutionID

	err = runtime.BindStyledParameterWithOptions("simple", "execution_id", chi.URLParam(r, "execution_id"), &executionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "execution_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PurgeProjectExecution(w, r, projectID, executionID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectFromGroup(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectGroups operation middleware
func (siw *ServerInterfaceWrapper) ListProjectGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectGroups(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachProjectToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachProjectToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachProjectToGroup(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitProjectGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitProjectGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitProjectGroup(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectInventories operation middleware
func (siw *ServerInterfaceWrapper) ListProjectInventories(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectInventoriesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectInventories(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectInventory operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectInventory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectInventory(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectInventory operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectInventory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "inventory_id" -------------
	var inventoryID InventoryID

	err = runtime.BindStyledParameterWithOptions("simple", "inventory_id", chi.URLParam(r, "inventory_id"), &inventoryID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventory_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectInventory(w, r, projectID, inventoryID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectInventory operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectInventory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "inventory_id" -------------
	var inventoryID InventoryID

	err = runtime.BindStyledParameterWithOptions("simple", "inventory_id", chi.URLParam(r, "inventory_id"), &inventoryID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventory_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectInventory(w, r, projectID, inventoryID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectInventory operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectInventory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "inventory_id" -------------
	var inventoryID InventoryID

	err = runtime.BindStyledParameterWithOptions("simple", "inventory_id", chi.URLParam(r, "inventory_id"), &inventoryID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "inventory_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectInventory(w, r, projectID, inventoryID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectRepositories operation middleware
func (siw *ServerInterfaceWrapper) ListProjectRepositories(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectRepositoriesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectRepositories(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectRepository operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectRepository(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectRepository(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectRepository operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectRepository(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "repository_id" -------------
	var repositoryID RepositoryID

	err = runtime.BindStyledParameterWithOptions("simple", "repository_id", chi.URLParam(r, "repository_id"), &repositoryID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repository_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectRepository(w, r, projectID, repositoryID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectRepository operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectRepository(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "repository_id" -------------
	var repositoryID RepositoryID

	err = runtime.BindStyledParameterWithOptions("simple", "repository_id", chi.URLParam(r, "repository_id"), &repositoryID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repository_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectRepository(w, r, projectID, repositoryID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectRepository operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectRepository(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "repository_id" -------------
	var repositoryID RepositoryID

	err = runtime.BindStyledParameterWithOptions("simple", "repository_id", chi.URLParam(r, "repository_id"), &repositoryID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "repository_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectRepository(w, r, projectID, repositoryID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectRunners operation middleware
func (siw *ServerInterfaceWrapper) ListProjectRunners(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectRunnersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectRunners(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectRunner operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectRunner(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectRunner(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectRunner operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectRunner(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "runner_id" -------------
	var runnerID RunnerID

	err = runtime.BindStyledParameterWithOptions("simple", "runner_id", chi.URLParam(r, "runner_id"), &runnerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "runner_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectRunner(w, r, projectID, runnerID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectRunner operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectRunner(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "runner_id" -------------
	var runnerID RunnerID

	err = runtime.BindStyledParameterWithOptions("simple", "runner_id", chi.URLParam(r, "runner_id"), &runnerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "runner_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectRunner(w, r, projectID, runnerID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectRunner operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectRunner(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "runner_id" -------------
	var runnerID RunnerID

	err = runtime.BindStyledParameterWithOptions("simple", "runner_id", chi.URLParam(r, "runner_id"), &runnerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "runner_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectRunner(w, r, projectID, runnerID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectSchedules operation middleware
func (siw *ServerInterfaceWrapper) ListProjectSchedules(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectSchedulesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectSchedules(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectSchedule operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectSchedule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectSchedule(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectSchedule operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectSchedule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "schedule_id" -------------
	var scheduleID ScheduleID

	err = runtime.BindStyledParameterWithOptions("simple", "schedule_id", chi.URLParam(r, "schedule_id"), &scheduleID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schedule_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectSchedule(w, r, projectID, scheduleID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectSchedule operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectSchedule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "schedule_id" -------------
	var scheduleID ScheduleID

	err = runtime.BindStyledParameterWithOptions("simple", "schedule_id", chi.URLParam(r, "schedule_id"), &scheduleID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schedule_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectSchedule(w, r, projectID, scheduleID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectSchedule operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectSchedule(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "schedule_id" -------------
	var scheduleID ScheduleID

	err = runtime.BindStyledParameterWithOptions("simple", "schedule_id", chi.URLParam(r, "schedule_id"), &scheduleID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "schedule_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectSchedule(w, r, projectID, scheduleID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectTemplates operation middleware
func (siw *ServerInterfaceWrapper) ListProjectTemplates(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectTemplatesParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectTemplates(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectTemplate operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectTemplate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectTemplate(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectTemplate operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectTemplate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectTemplate(w, r, projectID, templateID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowProjectTemplate operation middleware
func (siw *ServerInterfaceWrapper) ShowProjectTemplate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowProjectTemplate(w, r, projectID, templateID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectTemplate operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectTemplate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectTemplate(w, r, projectID, templateID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectTemplateSurvey operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectTemplateSurvey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectTemplateSurvey(w, r, projectID, templateID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectTemplateSurvey operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectTemplateSurvey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	// ------------- Path parameter "survey_id" -------------
	var surveyID SurveyID

	err = runtime.BindStyledParameterWithOptions("simple", "survey_id", chi.URLParam(r, "survey_id"), &surveyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "survey_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectTemplateSurvey(w, r, projectID, templateID, surveyID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectTemplateSurvey operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectTemplateSurvey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	// ------------- Path parameter "survey_id" -------------
	var surveyID SurveyID

	err = runtime.BindStyledParameterWithOptions("simple", "survey_id", chi.URLParam(r, "survey_id"), &surveyID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "survey_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectTemplateSurvey(w, r, projectID, templateID, surveyID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateProjectTemplateVault operation middleware
func (siw *ServerInterfaceWrapper) CreateProjectTemplateVault(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateProjectTemplateVault(w, r, projectID, templateID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectTemplateVault operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectTemplateVault(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	// ------------- Path parameter "vault_id" -------------
	var vaultID VaultID

	err = runtime.BindStyledParameterWithOptions("simple", "vault_id", chi.URLParam(r, "vault_id"), &vaultID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "vault_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectTemplateVault(w, r, projectID, templateID, vaultID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateProjectTemplateVault operation middleware
func (siw *ServerInterfaceWrapper) UpdateProjectTemplateVault(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	// ------------- Path parameter "template_id" -------------
	var templateID TemplateID

	err = runtime.BindStyledParameterWithOptions("simple", "template_id", chi.URLParam(r, "template_id"), &templateID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "template_id", Err: err})
		return
	}

	// ------------- Path parameter "vault_id" -------------
	var vaultID VaultID

	err = runtime.BindStyledParameterWithOptions("simple", "vault_id", chi.URLParam(r, "vault_id"), &vaultID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "vault_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProjectTemplateVault(w, r, projectID, templateID, vaultID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteProjectFromUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteProjectFromUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProjectFromUser(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListProjectUsers operation middleware
func (siw *ServerInterfaceWrapper) ListProjectUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListProjectUsers(w, r, projectID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachProjectToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachProjectToUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachProjectToUser(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitProjectUser operation middleware
func (siw *ServerInterfaceWrapper) PermitProjectUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "project_id" -------------
	var projectID ProjectID

	err = runtime.BindStyledParameterWithOptions("simple", "project_id", chi.URLParam(r, "project_id"), &projectID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "project_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitProjectUser(w, r, projectID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListGlobalRunners operation middleware
func (siw *ServerInterfaceWrapper) ListGlobalRunners(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGlobalRunnersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGlobalRunners(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateGlobalRunner operation middleware
func (siw *ServerInterfaceWrapper) CreateGlobalRunner(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGlobalRunner(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteGlobalRunner operation middleware
func (siw *ServerInterfaceWrapper) DeleteGlobalRunner(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "runner_id" -------------
	var runnerID RunnerID

	err = runtime.BindStyledParameterWithOptions("simple", "runner_id", chi.URLParam(r, "runner_id"), &runnerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "runner_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGlobalRunner(w, r, runnerID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowGlobalRunner operation middleware
func (siw *ServerInterfaceWrapper) ShowGlobalRunner(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "runner_id" -------------
	var runnerID RunnerID

	err = runtime.BindStyledParameterWithOptions("simple", "runner_id", chi.URLParam(r, "runner_id"), &runnerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "runner_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowGlobalRunner(w, r, runnerID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateGlobalRunner operation middleware
func (siw *ServerInterfaceWrapper) UpdateGlobalRunner(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "runner_id" -------------
	var runnerID RunnerID

	err = runtime.BindStyledParameterWithOptions("simple", "runner_id", chi.URLParam(r, "runner_id"), &runnerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "runner_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGlobalRunner(w, r, runnerID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ShowUser operation middleware
func (siw *ServerInterfaceWrapper) ShowUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserGroup operation middleware
func (siw *ServerInterfaceWrapper) PermitUserGroup(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserGroup(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteUserFromProject operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserFromProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserFromProject(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// ListUserProjects operation middleware
func (siw *ServerInterfaceWrapper) ListUserProjects(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserProjectsParams

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", r.URL.Query(), &params.Search)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "search", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserProjects(w, r, userID, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// AttachUserToProject operation middleware
func (siw *ServerInterfaceWrapper) AttachUserToProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachUserToProject(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

// PermitUserProject operation middleware
func (siw *ServerInterfaceWrapper) PermitUserProject(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userID UserID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", chi.URLParam(r, "user_id"), &userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, HeaderScopes, []string{})

	ctx = context.WithValue(ctx, BearerScopes, []string{})

	ctx = context.WithValue(ctx, BasicScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PermitUserProject(w, r, userID)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.LoginAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/providers", wrapper.ListProviders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/redirect", wrapper.RedirectAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/refresh", wrapper.RefreshAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/verify", wrapper.VerifyAuth)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/callback", wrapper.CallbackProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/{provider}/request", wrapper.RequestProvider)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/events", wrapper.ListGlobalEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}", wrapper.ShowGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}", wrapper.UpdateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/projects", wrapper.DeleteGroupFromProject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/projects", wrapper.ListGroupProjects)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/projects", wrapper.AttachGroupToProject)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/projects", wrapper.PermitGroupProject)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/groups/{group_id}/users", wrapper.DeleteGroupFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/groups/{group_id}/users", wrapper.ListGroupUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/groups/{group_id}/users", wrapper.AttachGroupToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/groups/{group_id}/users", wrapper.PermitGroupUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/self", wrapper.ShowProfile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/profile/self", wrapper.UpdateProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/profile/token", wrapper.TokenProfile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects", wrapper.ListProjects)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects", wrapper.CreateProject)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}", wrapper.DeleteProject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}", wrapper.ShowProject)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}", wrapper.UpdateProject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/credentials", wrapper.ListProjectCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/credentials", wrapper.CreateProjectCredential)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/credentials/{credential_id}", wrapper.DeleteProjectCredential)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/credentials/{credential_id}", wrapper.ShowProjectCredential)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/credentials/{credential_id}", wrapper.UpdateProjectCredential)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/environments", wrapper.ListProjectEnvironments)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/environments", wrapper.CreateProjectEnvironment)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/environments/{environment_id}", wrapper.DeleteProjectEnvironment)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/environments/{environment_id}", wrapper.ShowProjectEnvironment)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/environments/{environment_id}", wrapper.UpdateProjectEnvironment)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/environments/{environment_id}/secrets", wrapper.CreateProjectEnvironmentSecret)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/environments/{environment_id}/secrets/{secret_id}", wrapper.DeleteProjectEnvironmentSecret)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/environments/{environment_id}/secrets/{secret_id}", wrapper.UpdateProjectEnvironmentSecret)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/environments/{environment_id}/values", wrapper.CreateProjectEnvironmentValue)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/environments/{environment_id}/values/{value_id}", wrapper.DeleteProjectEnvironmentValue)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/environments/{environment_id}/values/{value_id}", wrapper.UpdateProjectEnvironmentValue)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/events", wrapper.ListProjectEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/executions", wrapper.ListProjectExecutions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/executions", wrapper.CreateProjectExecution)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/executions/{execution_id}", wrapper.DeleteProjectExecution)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/executions/{execution_id}", wrapper.ShowProjectExecution)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/executions/{execution_id}/output", wrapper.OutputProjectExecution)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/executions/{execution_id}/purge", wrapper.PurgeProjectExecution)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/groups", wrapper.DeleteProjectFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/groups", wrapper.ListProjectGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/groups", wrapper.AttachProjectToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/groups", wrapper.PermitProjectGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/inventories", wrapper.ListProjectInventories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/inventories", wrapper.CreateProjectInventory)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/inventories/{inventory_id}", wrapper.DeleteProjectInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/inventories/{inventory_id}", wrapper.ShowProjectInventory)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/inventories/{inventory_id}", wrapper.UpdateProjectInventory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/repositories", wrapper.ListProjectRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/repositories", wrapper.CreateProjectRepository)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/repositories/{repository_id}", wrapper.DeleteProjectRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/repositories/{repository_id}", wrapper.ShowProjectRepository)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/repositories/{repository_id}", wrapper.UpdateProjectRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/runners", wrapper.ListProjectRunners)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/runners", wrapper.CreateProjectRunner)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/runners/{runner_id}", wrapper.DeleteProjectRunner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/runners/{runner_id}", wrapper.ShowProjectRunner)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/runners/{runner_id}", wrapper.UpdateProjectRunner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/schedules", wrapper.ListProjectSchedules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/schedules", wrapper.CreateProjectSchedule)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/schedules/{schedule_id}", wrapper.DeleteProjectSchedule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/schedules/{schedule_id}", wrapper.ShowProjectSchedule)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/schedules/{schedule_id}", wrapper.UpdateProjectSchedule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/templates", wrapper.ListProjectTemplates)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/templates", wrapper.CreateProjectTemplate)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/templates/{template_id}", wrapper.DeleteProjectTemplate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/templates/{template_id}", wrapper.ShowProjectTemplate)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/templates/{template_id}", wrapper.UpdateProjectTemplate)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/templates/{template_id}/surveys", wrapper.CreateProjectTemplateSurvey)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/templates/{template_id}/surveys/{survey_id}", wrapper.DeleteProjectTemplateSurvey)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/templates/{template_id}/surveys/{survey_id}", wrapper.UpdateProjectTemplateSurvey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/templates/{template_id}/vaults", wrapper.CreateProjectTemplateVault)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/templates/{template_id}/vaults/{vault_id}", wrapper.DeleteProjectTemplateVault)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/templates/{template_id}/vaults/{vault_id}", wrapper.UpdateProjectTemplateVault)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/projects/{project_id}/users", wrapper.DeleteProjectFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/projects/{project_id}/users", wrapper.ListProjectUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/projects/{project_id}/users", wrapper.AttachProjectToUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/projects/{project_id}/users", wrapper.PermitProjectUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/runners", wrapper.ListGlobalRunners)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/runners", wrapper.CreateGlobalRunner)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/runners/{runner_id}", wrapper.DeleteGlobalRunner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/runners/{runner_id}", wrapper.ShowGlobalRunner)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/runners/{runner_id}", wrapper.UpdateGlobalRunner)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}", wrapper.ShowUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}", wrapper.UpdateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/groups", wrapper.DeleteUserFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/groups", wrapper.AttachUserToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/groups", wrapper.PermitUserGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/users/{user_id}/projects", wrapper.DeleteUserFromProject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/{user_id}/projects", wrapper.ListUserProjects)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/{user_id}/projects", wrapper.AttachUserToProject)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/users/{user_id}/projects", wrapper.PermitUserProject)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdX3PbOJL/KizePSpRks1dXfnpnEwmm9rMxGsnU1c15UrBFCRxQpFaEJTjdfm7X+Ev",
	"QfEfCEAiJeMpsQiCje4fGt2NRuMxjLLNNkthivPw4jHcAgQ2EENE/7os8Pp9toBX5FfywwLmEYq3OM7S",
	"8II+DqJsAcNZGJMf/lVA9BDOwhRsYHgR8kd5tIYbQF7HD1vye45RnK7Cp6cZ7eIKZbt4AVHbV9IgXsAU",
	"x8sYomCZoQCvYQDIt7f8TfH9LcDr8vPKUwT/VcQILsILjArYQdIs/PkC/gSbbUJ+XcV4XdyFnM4bDHAn",
	"K3LSoIUX4lkXM94jSAcKkravBJFsojIlQ0GeFKtmNpSvfI8X5rwou3nxOiSPVtkL/oWS7k+/kNc+pLsY",
	"ZekGprh1ILBsoz0S5R2roSj91Mai0M4H8xNGBSG7fSiihf5AxBt2wxC91AchnrAhfERZsW0lf0WeapNO",
	"W1uRTXuokUxpZOR+SncwxRl6aCU5Fi20yZZvWJEue6mRL2lmQ7gCqzhdfY43cdsMYC2ChDRpURniWUnc",
	"Ai5BkeDw4vWrVzNBapxiuIJoj9bXr15JOr4slznsISSjbVookQ8bSOkjhJKBsr9g1K4Mtuy5tjR5eytZ",
	"8j5qkuS0Mjlew22Wx51YRLKJNvnlK1YjKLupDaKkm4+jSNP2BTZA9LE+/bS5He20izrd9GdG8020hosi",
	"aV1xg5w30KZbvGBFueikRrugl1MPAYrW/yTzqGUArEUgplqj0UCb9FgNNzBCsH1u5fSxPo9oczsO0S7q",
	"/KE/c+5kCL/PkmLTtqqSBkQtRbRRG3syhPuYkyH8BbUbl+I7GVLMyH3tx581KL8Q5FE4C2FabMKLP/lf",
	"5Avh7aybSbQRIbBAO9iuXXL6WF96tLmd9GgXdenRn5n0vsLNNumwhQPMG2jTLV6wolx0UqNd0Muo/5Z3",
	"aMIiH6AHSWMriv9aZHCPVkIdo/MPkBTtLN6Rp9qU0tZWpNIeapylNApyiwR3kFskeAC5RYItyS0S3EBu",
	"kVAN9MQ6hjl+ly1iSJ3d9wgCDD8m2R1I2Dr0Lls8kCdRlmKYYvJfsN0mcQTIuOZ/5WRwjwpJW5RtIcK8",
	"Q/bRfUIJRWmRJOCOEMoG9fNFtokJfPED++lppto4jX00WSy6fVPOG1OGsx8wNX39SerF7I5QHT6Rn6pw",
	"+bqGwiRZAAwCnBG/l/nPVTwwp5mIjbgPo8rLhqe6TGGumi5POC4subKAm0wZ112WJRCk2myZPlOF8zGQ",
	"rWXQw5LBP+J0Yc6hJFvFtPv/RHAZXoT/MS8DenP2yXxe0vqZNreWS7aDCMULaAGMfA2TRJ/wG9r8SJBQ",
	"omwDUaGEj8bVRtTYph2RR3kfoxW6mZ0elrwCCIGHI60t1MwwIpuaIoZU6+JCDVqaA4Mx2BIeymtmnLZT",
	"OzboNOE292LNmU7h4Xk+hOfMxRjKchF6tjY77ip6ZOjyonqUPfaz4h46ZqbcGBjIRBlNtmTiHYyyjQ4L",
	"3tGGAzwI66lQ3ZXqIa+ywTT9yTbbi/D2jK4SrJ2SZVxuswzEbzkiWwAjkEbrMVA2qusyCwuU9JH77fqz",
	"a5+73MoYKvDx4yXnF9PgvBX7CpbcBRGOdzYOW4SydCx9aincCdgCcrNqoPQFQbbST5Ls/rsDtx2gVbER",
	"2UJm4rBV6hXmmnayl0vSA4tqVoj2N6j9lyFzKitpCz00qikI2tEjmmLgeFI/zVg4/0ytpxnfItOPUog5",
	"zPbQjCMrdE9j+FfppseBAyNyw89QuzHOWLuMDvTCuF6D4JW52xvjBB4t/FZC7PCxN1uI0WlgGwA6a6eV",
	"cfzQRvBgOX7LrT2L0vaVmRtsGKZG0GLDNl1kd0uQ5Ob9wQ2IE3PBLYsksdxsBnl+nyEKvWWGNgDTPXn+",
	"48zUic0hOkbQkiZt9MOJpcEyrfALymy3i/m+YXPeUfnxP2XD20G7vPvbkkWaxOmPvnFdQbSxHRdEm2aj",
	"buiAZ6wvu3GTLmgabPO4iXZwIEwCof6B0VbDhlPBZo8MaWbSAQU4YJBGoquMtV1udA/6ssBr23EOUlqd",
	"+qiJB7SlohpvB28e54QPoMBr8mfUopX4xKUAcABkKon+AbJmtwNTJKr5J+1oVsfkANBtY5q1Qb1xsAMh",
	"3TzmdlTzMU9XH4kBaWokZTynqZMax9suv2u4iBGMsAPF1BJM3h8Ua3arHZxn9AX0NR3N8m278AmNUw3+",
	"F1Q4HWJ7hgmNfTy5Qtkytt4I8c6WbbokEcIQoTnIQj29NFJNvvg00meVRqqJCp9G+tzSSIcDw6eRHjCN",
	"tI3pPo30YGmkFZb7DEifATnJDEhNPX0GGZCnkNk1lTRJXVT4NEn3kRKfJnnOaZKa0vdpkqebJnmSSY76",
	"wT6fCfmsMyEHKjCfCekzIQ8MMZ8JOdFMyD45Os2EtE199KmOo6c6duAlh2jSGUV0HLrpRHI0p5pL1DDa",
	"9kQUmnEz/SxVOib9JFVlVKeco9o46jZZ0k/m2yzNGdWXEenpVxAncPEBIXYwTJsDXebH7xmOl/zVJtLZ",
	"Nwmt7EwaDAClhZbTRjDPChRRs+UyQRAsHi4xBsQTPy6V15yQIM4DwAgJAKeEEPcOLEpTIj8ubd9SUOB1",
	"huJ/w0VwH+N1cI+ydKVme3ISr1lhubEEvAUohwGvbkerP9MEsA/Eb86vORxt0md2Iqyht7VKmtcMYtUr",
	"l4twnOL/fhs2lRPm9Yf1GuMMg0SrbS0fj7w4k3WXZdVjPmQdHXEZRFmSQDa5smXAX5ViYBFgIzF0cZl1",
	"26a0FhCDOMnpZAc8vLpPkgtoHEykjGR90F3LIe6jzj04BG0m6BDv7h3icCELaed08Yl+9KCTkS+V+qJT",
	"+XAcAUoSTSRYObNSCtL5BOeS0pnfKyFUeabkjPCkL37mk+kDTzoZddTpIol90BxG7H0hOWdSGzj5Tnyx",
	"5kM2lkLOrqDAxJ9PbiDaQXRcU+4m28Ag5gQEOaUggJQEdjkGSOLF1+wHTMcyMVcwhQhgGGQooNSQ/7Ot",
	"YXG8y7kCvCzw+iv7RJ20j5ygBT8cQe1z+HMbIxpco57N7xke36tJM1zxaAhR0q04skNDK51zkiQNnKhf",
	"syIdi02EoCX5fshOIS3jBDqHE++3NXO3QAimuEx2ZytsWJ6LKh1R57SVXest+EqacbYMgLBGGol1saio",
	"Lq/uyqKO6YjLixIO6kGDtDedL0gqu0xWJfU8KRN4XcDKxrtzOCp96+FRTf5sAWQtjfmQVItMdA3a06Zs",
	"4f4x0F2/Qw6BbysOHgHLve0fgJPAkNKdSeb9s1MMFYYZBZeUDtpVw7MJ/E1CprahwnY5imLC7vWM6FlP",
	"vcsUvTa1IrpzAjrZmT7wyuE8N/CVzDIBoBBsOwZHjUt0BAXPWqoWAY1KDQvVexFplDF0Ic247E1bpDKR",
	"89nJU+WWiVCV91snquSu88VCkZvOYlEeoGlZLb4UeFuYmf9aOGP9N8R0G4lPshW9DZU7MrJ+fwvxMuPW",
	"zTyaEOyRMjL9bTeZgHykrTeVSKP9N6WD1rlUjsr9tq3CMK2t2/LkUSsi3QfKuvJhqvQ10DOV/e5Whk1/",
	"99tg9p73fnkr2sQZMOd4Ex278ZBEb2eGOuk/aOOuZOsxkFfSdxjvSOTXO0ef6FgPfTKtvAV91ZMmByNW",
	"HPEZRDK/7riHcnqA4WCE81NCg+hm19v2kH1m010MfvghmeNM95I+k+ku326d7q4ya07S2TXJrmkN4Bw+",
	"v0atBanGQU5BfvpMPp20OTVh7gplu3jhZi5tRV9DeEbfOAjTSnJMmAQKvA7KLmiN0iWC+fq4yTX8o53J",
	"NTdFFME8/w3mOVjBo+WMXCUgToOcfTzY8K8/zUI6mHFzkFJI87YIn/jZFJlhOEIEvSO7cULZmjqjOErg",
	"vDywlYfVw0vntWJ0Lstjy89qhVEPakkZOtcIfEA6aRmUP5yOSYPosEbgGNaftPr+YMmqcTZa6qxMl1UO",
	"aP0BUbx8OMhqxbpuIuk3iAE9v0h8nTVkxgbP4eWxnA1gpxblqtewO0+sgPw7qGKLDPAFjjfsaDJYfEmT",
	"h70bd0zrTnV3p1thfRYqzGnKbyTr+OFHpR4aHzYw+WbT2JRcy/1aIOFv2QImBIgIbhHMYYqV/EKmc11y",
	"4mkWatT0obftinoPMC02ZIiMVaLAr6hQfNvwBbe1i7vLEhvWsXdeqJigh57+txFOWSVFxUwnoj4LXg+A",
	"VcAENOu4vmXgVS11qoPP/BsdtN8ICQyhXcBvAO1bFO8Aht9/wAc3Y7vhNNTGpmZP6oxLSRgcda633xtq",
	"OLecl6k+7MRzX6BaRc6HipS7QMMHPxA6PC+6jqC2irgWq8AOIJYp26j5+2eRMtjgRpDdxRLG3qEcoeI8",
	"OYb8wamu82OnrVF2TbqEFZdQyZZln2XNmgVMIIaNowAYI7VwYkmYCyXFevu+iPNtApo1NG/SL6Mvd6US",
	"4i+x5pWRlytrVQHL/CIRrPheViVhf/N7j0TRGZlNVXrH32VBGv63uCpJ9lQmjcjdd2UzVNko4T6W7JH+",
	"Ufazd9lUXWm3cnQKNwTRwVhTSHtZg3RhU1qOdtI/RuItD6qvKmb4rk3xS7hpzWwFnHolqR3NzwW8qyy8",
	"iukNq/aOsVJtqQg6/EZzW5OlscccA1zkjY/kVB2y02pU1te1g/FBgVMNmR9FcYFeVCrablK265HKnbuU",
	"yEfOymZpXJWbx3pCCZSKWs6FM6z6BFs7+wVKX2BSFQXF5IXO4spBsYxn92zd5D+zMogdq+GAvVpDDeIE",
	"DLXSdoSKCkm3e4gJrqSca8gpk8N1YLNnzdRu7Rh2pnj4TR9dl3g4WsuiSihOfzDm5VUtXAuy7sRROAvp",
	"yfgB7oUxhBXTdFBquXlZ7KMF1D4p4K7Nk8p+QW2q0J3kOApE7UC6g0QLgOQBSBdiD4Ge89qfOayZdlyh",
	"3BBpioBsyu38OoMb1rZ9u0VsFPUYrBVuNHCLH+HQUSkZa9rhiOtMWetpD1VLW/usonxLp9K+aEswrfDy",
	"i2BAjYui4oUOG3nZi0a/fte1XaHY6rJQsEbTAq+H7SJeFnjNFEFj38OqyTuR+NhljW3yQZxwUXfVOUz9",
	"5W2JbqvYg3HqhBMeuogsu6hEzZXJlVQDTdpE2z04pGNgveNwHGugw2aWCYg6rKykBNYYqoS3+qMsKN6x",
	"j/bzOMpSrYb6e9kKX8RQaoy5rhiHvayphDmPGrCatJHvfKvtkLtimte5qQi6VsVexxALd2vhR0TGp7st",
	"eviYQqt0Wy5+c60nr4UQapKUR8V0ZKlsbmhef+FMFWSpVWT6aNP1dCPJN8rO1T5Kviqj6kWJsu818Ba4",
	"7gveOu5uc7ZF0nG/U32fZEABLpv73qQLyzIrjedArEYRtWuImN4iN43toGlFwka61s1NYs0oV8Nx3fS1",
	"VCmtuokzaYiG4udi6wZ/jx4wjwTzpmmxuSu3QeSu5aDYcMddbu3XtLm+ga1JSMGN4GqrrPSzgZSjwE2p",
	"QNbr/05Q0r4wynG15vVU0T5wWOSVWWsp2GO5Pq7DUfvQVyJR/Ba4QWC3vzmuLkzG+Jowv+Wank2ZETSl",
	"i+B80Nc+6HviMdeJhTu/5c2up8Se7mSjYbqDRBK2SrCwYaFdHt5Dp2XjL9n4Gjmln8tTHrJ87jkjriaC",
	"7gG8YRmITYePWJqIZNrtHkBac4vUXRNtjBxyA+FZJv6Mg5bmpCKKl479ESVFoTlTAiRBjlER4QJBAp58",
	"nd0rORI8c6IGnmUMk+bzO61pD6oeVMiqn0iljlKBYvxwQ3jJPvgO5HEkj29Sk4n+Il9fY0xV0TsIEJNO",
	"2ZL9VGv6dwj4akBssXDN/hT2afh/Ly6vPr34h+rjgG38D1GWKU6XmUiPAAy53KQJV/AnjP73Ht6t4+02",
	"hi8XsOz1I3kW8mg9JSW/mM/pGy9hEdaP4159ChZwGaexvHKSdjELALtKJo6UUpvE6iWYpu0u0zy+S+D8",
	"yxamX7NlMf8KEQLkMT0hHEF+YJZTdrkF0Rq+ePPyVYW8i/n8/v7+JaBPX2ZoNeev5vPPn95/+P3mA3nl",
	"5RpvklBNkCREBeTTl1efwlm4gyhnI3r98tXLVy9Asl2D1zT1fwtTsI3Di/Bv5EnI4kNU6nNiC8zlEcVt",
	"llM+EyRS9HxahBfsyhy+qPKDweKC1KYJWjaJyRDEy/SV/TtH37x61d4NbzevXtnzNAvf6ry1f9clfe+1",
	"1nu1azyfZuF/6Xyz6WImdb6FF3/ezsK82GwAeiCIKPCafCgirhQ/hR/cPVSu7ZyFGKxyoquo3XZL+mNi",
	"q5STWcEmycU5lgVsQhPe18vfdI3nV4ijNTuwvQMxtW3368S0DwfBRYz4EtUMxGvewhSL6vvmcKxWbzk0",
	"HOs3ah0KjNcQoxjuYIAgSHiZGLDEEAVSMl3Co2V4WpHIy/RIyQ1l+n5toRHZpzCM0kQmblmfILiDywzB",
	"IMa8ClEX5HfyjH8j01gJAGOe7VVumALLGEnM/onxg6g+Ako9SBZZtp3bzrZHoU6e5hFIkjsQ/Wjl4Xve",
	"QMnl2AIENhBTxfln85jKJrRQhXj5ivwcPs20XrrBAMNBb7zPFuKF2z2B/+3V/+yf2YQ/8ZwaBZWaG/s2",
	"YUclKFH9qbwc7+2rt46+IjhWvS/t7es3jvova5ZQww0k8b9hmXpUAtbBpz41X3bYoUkF5soLrzGtuLOM",
	"U7hQE6Q0AC4qsbQrVvrcJbwPhz2xABPGEJaoAjs09sYEBBcSHTNSeKAHifJqo1YjT71FfTAEbiBA0fqf",
	"BUQP2urqCqzidPU53sR44DtfaMWkFqhprWuNV8ZTBP2t/+WGOy3dLW/M/gVJIm5WL+XJjqIzgZbZ0O0C",
	"ZU2OIcqbDOH3WVJs0kGvfEFDFsRR8VKtajgxpJSe0krIXGCGxYhvn2Yt/tB7GmEU0czB7pDyurk3VL1Q",
	"3MobMpbJ2zdvNKzhvepq7mTJ+BiAIIX3csdgX4blvJ8/isD0E4sZ0koTNeH+Qn8Xwh2mBtgZWYsps1cx",
	"VVesl7SyBrPNnAiW2QS9ryoXArsTKxNAAIJ8C6N4GUetsp016/GbdXY/kvwaZuVpCoHrSR0Z8FN4VRl8",
	"o7sRjqQwUL8q3z5x/WqEgJG1MuO+DnQaVfNcPXKloaN/Rdmm3Cc6LtDUkgi/oMwCbYZ6fxJwe/1G74OV",
	"a/Yd4i1N4vRHeRdDsETZZuiSIU1/Uc/ZCksz7y8Yq9xaQe3TX0STRJacDgCfBQHOupbURreDzSDKpa/Z",
	"FHTeFUQbr/NajfIEQbB4qOm9kddnRo+iL7uR2GTcEbnHFX3pYXhSS+80TEQBwC1EG1YQf5ilKMvMa5qJ",
	"PJNzBKCSL3sDcWwDkWZ5WFmH9JYGbxqOZBpW78g4C7uQqjB3RuG4Gs6vw6dsDlLtaGULevR5K3C4Fchy",
	"+bVMQH60aJ7DZNm6i3uzzu7LEkVGmZfk3SluW/Lxyzuk+CU9W4jyLAVJAKIoK1I1XVAcxuqJ06v8Mgq2",
	"8w7M518j15/bhiafEQ9ZgYLsPpXyjlN2nIMfK6jJVp0bsiRL4+SgyYU2s6MhCXfsuSHzZ0EaFCmt2gAX",
	"6s1VHSyTOw1dadxmAWFvxzdPc5fR3QMmhWxLuSvoobGuvsSQK+WSBaPUEN6BlTYlHfj0EJkeUh4WrEtT",
	"1QU0BZSfR9NIEzENf4rIpU8VcZwq0iXnWafBOJYcG+fqmSSNdEuj2yB1JQ9Te/YsNPB5JJAYKe+5ephP",
	"w8J7Xzn7ZwM7H+O1UYSKHM4r1qvgkZ2/6sB1pXyspr1Zuazz2GqzhRJrBVp25VWppQlcuXKuB3BaWnX+",
	"WCnYpW8uO0Nqv3IqP+Vtbde2tnIf7mB91meJnxxEevTVmRj0NiLvN/dHF7qNr+AXvcn6D+aobV8HlZLI",
	"Wu7FB7W99y/G8y9UQZyXg6FCUgPoajlwTRejeof4qD6GQoq1vlX68grX0suo3mXdhzo9/Tp/rBag1/c0",
	"3AG2X08p3/K+hmtfQ71Wf7hq6/M2ThAmfarrTBwOO7n3uxwTkLyN0+FXwQm7HTbYNVwY5+wqhry9ll+b",
	"EXXD7nA4jTnQPQiXM4H16OeDpVXIYBlkaQDS45iIYibMH9l/TM3G0eaFjpdPSPO2pitbswWjh7Y7Tgph",
	"jowVr6inaLi4mgCmKru822mY7SJuNjpl04WOweWEoB36+WBpuFBIHtVuYZNg/kj/NbVaxpoR/e9QyrzN",
	"4shmaYHnoU2WE4KXI4PFq+fJmSuusN+hqHfau7u7ye7rTmHLdXeGm627zm1WtexwC7jE3TZ6ACtb++SB",
	"EZEsxXBmaJbj0lGforF22oB8YeykAUGI/UouevJLuG3CgAKObqzp6NL5o/z/MN/JEUQ1rFrxJe8EOU8S",
	"kNfFDVVivQkCpwWPbiV1LqkBhtI2UCPzrMDcQW5Eyhf6+KSxwoZwDkBhIxkLKdsCsUtCG4FyRZ76JedU",
	"oUXFd1hklXfUaNktv6JsY1Zl39605j3Qz/vqlmNXt6TAYeUtDYogKKEGwyuQfJjBXZjB6c1JEwkxMMVW",
	"qXXZUx6io94l59PXbAq6z1cePOW6l0xv9qOxvfiligUPRV8E02A3i4GwrIJpVvEkTncwxRmKodaewiel",
	"uV/tx1vtFTmc15Kv4FHDPxKtH3S3FT7JF0beVpCEWG8ryJ78toLltkKsgKMba1r6dP4oXxm0r+AKo/1K",
	"SX7JB3lc7ytI0Q/WYn37CicGj24tdSb7CubS7s+hG1neNslwfpGb6DFDU7y2r3sIbrM81nckrtX23pMY",
	"z5NQBXFeroQKSQ2cy+bazsR1+cbI3kRJiYPys6Irr2ot/Qmk4qMHcHqadf5YvjTIp3AG1X79VH7KexWu",
	"vYpS+sMVWp9fcXIQ6VFYZ+Ja2Ii837kYXeg27oVf9SbrYJijtmMhLNKU397a613wpt6xGNGxYDI4M5+C",
	"DUoH1LSltivBWo/tRlAq7JUp7cYrUlv3QWCiA1y92nL+yP4zzFtwgUYNi4B+xnsJzr0EytdhOqrXOzgV",
	"SHTooHPxCAzEq+EJjCVgKw/AL1iTs/wHo7N9DcujNVwUid6Owo1s7K3+8ax+KYXzsvslEjWALdrq2v6C",
	"ZWNb/4IOa3UqOvIK1bYEZomMTphpaND5o/jvIE/AETY1lB3/kPcGXHsDQu5DNVefR3BS0OjUTGfiF5gK",
	"ut83GFXUNv6BX9Im6SOYIbV9lcNws00A1vMTvsrG3k8Yz0+QUjgvP0EiUQPaoq2unyBYNrafIOiwVqqi",
	"I69ULf0EXCKjE2YaGnT+KP47yE9whM1+NSQ+5P0E136CkPtQzdXnJ5wUNDo105n4CaaC7vcTRhW1jZ/g",
	"l7RJ+glmSB28ys3zAu3gg+4tAkLGN/StU8B6B/nOEM+687i3DflSNtIS1Ycz6wTg54/sP0am3jjw13CH",
	"KV3ePnRlHzYA8nCWw+mAyoW54VXw5EwPa7QPV8Y7UCR4qPHxB3npZG0PSr0z3NPePOytry0qEnxow4Nh",
	"ff5I/zUyO0YBvs4lMkXi71V0d0dRDYuHszlOBVEuLA6veKd2IZEl0NtVcJHzw1LaRYG/5aMcQeE9kK/7",
	"ksBjlwQmqHFREfhb7s/fjbvDTiVwXrvrVKW5Lgc8vtbzFVhPuRgw1ZgOagF7HPpKwGZmJEWgfiFgnXP0",
	"H5PsDiSmx+j9stwgzgpLHa3LhzrfrmBH8xy7OrrQOEyo9mKuidRexvZOJxTgW1G21I+VVw7iGR0b3xP+",
	"MGXhT4Ef8hS4Iud8DRBcaB77Hlmk7VP4rA5x90inI4bpWD5GscXz09bndAS7TcPLuGCr8WcWu/FGX4P4",
	"XAZhnBt7YAfiBNwlzINQjT7yd6/Jxx1WQ1OPvG2uNMjb3rSTpl2RV+Y7F5+c7fNH8o+eLWcUhqDRA2/B",
	"ObbgmqXaYbSNIrv6VDwTE62N/R1WmRMBGNlip69Oz8P20tbE2re2EtmYX9lqC64cIn9Z69Quax20MAiL",
	"3vCOVgVAfj/WeIF8Jrezti6ZHRuxhD2ml7K60m5+5+ssrmMdZLGxzVcJAY89v+tqdf+qvuUn8vX0bb8r",
	"uaV7dIzyT3v7b2z7j6PGwgK8ErjzNuAYNqBg/3lZgUKZObIDx9d0fj0+ZVtQaElza9Aj0FuEZhahwF6v",
	"TUhehlGBYvxAkfV3CBYQhRd/3pIl6R0ESPkL5HFE/7glbxESGBwLlIQX4RrjbX4xn2P08HIFf8LoJSzm",
	"YBvPd6/Dp9un/w8AAP//u+f42ZbNAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
